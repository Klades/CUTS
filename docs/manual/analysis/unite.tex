% $Id$

\chapter{Understanding Non-functional Intentions via Testing and Experimentation (UNITE)}
\label{chap:unite}

This chapter discusses the a tool called \textit{Understanding 
Non-functional Intentions via Testing and Experimentation (UNITE)}.
The purpose of UNITE is to support analysis of distributed
systems quality-of-service (QoS) metrics via system execution 
traces. This is usually a \textit{challenging} problem when
dealing with data is collected from many different software
components that execute on many different hardware components.
UNITE therefore provides the necessary functionality to 
analysis such metrics so system testers does not have to 
concern themselves with the accidental and inherit complexities
associated with this domain.

\section{Overview}
\label{sec:unite-overview}

UNITE is a method and a tool for analyzing system execution 
traces and validating QoS properties, \textit{e.g.}, performance, 
scalability, and reliability, whose analysis typically varies 
across different application domains. UNITE's primary purpose
is to support validation for distributed software systems,
but it can be used to analyze QoS properties of any software
system that generates a system execution trace. 

To provide a little more background, a \textit{system execution 
 trace} is a collection of log messages. These log messages are 
related to an execution of the system during a user-defined time 
period, or the entire lifetime of the system. 
Listing~\ref{listing:execution-trace} shows an example system
execution trace, which is a sequential listing of 
log messages for different events that occur throughout the
system's execution lifetime. The system execution trace in
Listing~\ref{listing:execution-trace} resembles many execution
traces that are generated by logging frameworks, such as log4j.
\lstinputlisting[label=listing:execution-trace, 
 caption=An example system execution trace stored in a flat file.,
 captionpos=b]{analysis/system.log}

Using the system execution trace above, it is possible to 
evaluate the authentication time for a user. Likewise, if
we many different occurrences of the messages illustrated 
in Listing~\ref{listing:execution-trace}, then we evaluate
different statistics related to authentication time, such
as average and worst authentication time. Finally, we can
view the data trend (\textit{i.e.}, how a metric evolves
with respect to time) associated with authentication time.
The main challenge, however, is ensuring different data 
points are correlated with their correct execution trace.
Otherwise, there is great chance of producing incorrect
results.

With this in mind, this chapter discusses how to use UNITE
for evaluating user-defined QoS properties via system execution
traces. In particular, this chapter first introduces concepts
related to instrumentation and UNITE. This chapter then 
discusses how to use UNITE. Finally, this chapter

\section{System Execution Trace Concepts}
\label{sec:unite-concepts}

Table~\ref{table:execution-trace} shows another sample system 
execution trace. This time, however, the system execution 
trace is stored in a central database for offline QoS analysis.
You will also notice that this system execution trace contains
more information, such as time of day, hostname of origin, and
message severity. Although all column in this table are important, 
we are going to focus on the \texttt{Message} column when discussing 
the following concepts related to system execution traces. This
is because data in the \texttt{Message} column is of most to the
user using UNITE. The other columns are used by UNITE, but they
are used internally. 
\begin{table}[h]
  \begin{tabular}{lcccl}
  \hline
  \textbf{ID} & \textbf{Time of Day} & \textbf{Hostname} & \textbf{Severity} & \textbf{Message} \\
  \hline
  10 & 2011-02-25 05:15:55.34 & s.cs.iupui.edu & INFO & Config: sent event 5 at 120394455 \\
  11 & 2011-02-25 05:15:55.35 & s.cs.iupui.edu & INFO & Config: sent event 6 at 120394465 \\
  12 & 2011-02-25 05:15:55.38 & r.cs.iupui.edu & INFO & Effector: received event 5 at 120394476 \\
  13 & 2011-02-25 05:15:55.46 & s.cs.iupui.edu & INFO & Config: sent event 7 at 120394480 \\
  14 & 2011-02-25 05:15:55.37 & r.cs.iupui.edu & INFO & Effector: received event 6 at 120394488 \\
  15 & 2011-02-25 05:15:55.52 & r.cs.iupui.edu & INFO & Effector: received event 7 at 120394502 \\
  \end{tabular}

  \caption{An example system execution trace stored in a central database.}
  \label{table:execution-trace}
\end{table}

\begin{itemize}
  \item \textbf{Log Format} -- Each log message in the system execution 
  trace is constructed from a well defined abstraction called a \textit{log 
  format}. More specifically, log formats are high-level constructs that 
  capture both constant and variable portions of individual, but similar 
  log messages in a system execution trace. For example,
  Listing~\ref{listing:log-format}  
  highlights two different log formats which capture the log messages from
  the system execution trace in Table~\ref{table:execution-trace}.
  In this example, \texttt{LF1} represents log messages 10, 11, and 13
  in Table~\ref{table:execution-trace}; whereas, \texttt{LF2} represents
  log messages 12, 14, and 15 in Table~\ref{table:execution-trace}.
  \begin{lstlisting}[label=listing:log-format, 
   caption=Example log formats that represent different log messages in a system execution trace.,
   captionpos=b]
   LF1: {STRING cmp_id}:sent event {INT event_id} at {INT sent}
   LF2: {STRING cmp_id}:received event {INT event_id} at {INT recv}
  \end{lstlisting}
  
  The variable portions of the log format is specified inside placeholders \{\}.
  The information captured in the variable portions of a log format represent 
  metrics that  are very useful in QoS analysis. In the above example, the 
  the time variables \texttt{LF1.sent} and \texttt{LF2.recv} can be used to 
  determine the latency of different events. Table~\ref{table:data-types} 
  shows the data types currently supported by UNITE.
  
  Each log format consists of two parts: \textit{data type} and 
  \textit{variable name}. 
  The data types gives UNITE an hint as to what kind of data it
  should be expecting for that placeholder. It is possible to consider
  all data as a string, but this can complicate the identification 
  process when different data types are string together (\textit{e.g.},
  Host5 which is \texttt{\{STRING hostName\}\{INT hostId\}}). The 
  variable name is used when constructing the dataflow graph and the
  expression for evaluating the user-defined QoS property, which are
  both discussed later. Finally, Table~\ref{table:data-types} lists 
  the different data types currently supported by UNITE. 
 \begin{table}[h, captionpos=b]
  \centering
  \begin{tabular}{ll}
  \hline
  \textbf{Type} & \textbf{Description} \\
  \hline
  INT & Integer data type \\
  LONG & Long data type \\
  STRING & String data type (There cannot be spaces) \\
  FLOAT & Floating-point data type \\
  % Manjula, what about the other data types you added, such as 
  % REGEX and TIME. Are those not supported by UNITE?!
  \hline
  \end{tabular}
  
  \caption{List of data types currently supported in UNITE along with their
  description.}
  \label{table:data-types}
\end{table}
  
  \item \textbf{Log Format Relation} -- The other main concept in UNITE 
  is Log Format Relations. Log Format Relations define a cause-effect 
  relationship among two log formats. For example in the above example
  \texttt{LF1} represents a sent event in the distributed system. And \texttt{LF2} 
  represents a receive event in the system. The sent event always 
  happens before the receive event. There for the log message corresponds 
  to a particular sent event occurs before the corresponding receive event.
  We say \texttt{LF1} is the cause log format and \texttt{LF2} is the effect log format. In 
  order to relate the two log messages distributed system testators can use 
  the \textit{event\_id} variable as follows.
  
  \texttt{LF1.event\_id = LF2.event\_id}
  
  \item \textbf{Dataflow Graph} -- The dataflow graph
  

  \item \textbf{QoS Analysis Expression} -- After specifying Log formats and 
  Log format relations distributed system testers have to specify a QoS analysis 
  equation to get the results. For example in the above example in order to 
  get the average response time following equation can be used.
  
  \texttt{AVG(LF2.recv - LF1.sent)}
  
\end{itemize}

The next section ~\ref{sec:unite-config} shows how to specify above 
mentioned details using the configuration files in UNITE.

\section{Defining a Datagraph File}
\label{sec:unite-config}

UNITE uses two xml configuration files called, \textit{datagraph file} and 
\textit{unite file} for the configurations. The \textit{datagraph file} is used to 
specify the details of log formats and relations. The \textit{unite file} 
contains a reference to the \textit{datagraph file} and is used for the 
QoS analysis.

Listing~\ref{listing:example.datagraph} shows a sample \textit{datagraph file}. 

\lstinputlisting[label=listing:example.datagraph,
  caption=An example configuration file for UNITE datagraph.,
  captionpos=b,numbers=left]{analysis/example.datagraph}

\subsection{Datagraph Schema Definition}
\label{sec:datagraph}

This section discusses the details of the UNITE datagraph configuration 
based on its underlying XML Schema Definition.

\xmltag{<cuts:datagraph>}
This is the main tag for the datagraph configuration document. Its 
XML namespace must have the \url{http://cuts.cs.iupui.edu} definition. If it does
not have this definition, then UNITE will not execute further.

\xmltag{<name>}

This tag contains the name of the datagraph. This tag does not have 
any child tags.

\xmltag{<adapter>}

This tag contains the location of an external adapter module required for 
for UNITE to correctly analyze the QoS properties. This tag is not 
mandatory. It only needs when the system execution trace does not 
contain required properties for the QoS analysis. See Chapter~\ref{chap:setaf}
for more details.

\xmltag{<logformats>}

This tag is a container for set of log formats that will be used in QoS 
analysis process. It may contain any number of logformat elements. 
Log formats can be specified in any order .In general, cause log format 
is specified first. Then its effect log format is specified. 
The following is a list of child tags: \texttt{<logformat>}.

\xmltag{<logformat>}

This tag contains all the details about a particular log format. It has the following 
attributes.
\begin{table}[h]
  \begin{tabular}{lcccl}
  \hline
  \textbf{Name} & \textbf{Type} & \textbf{Default Value} & \textbf{Required} & \textbf{Description} \\
  \hline
  id & String  & & Yes & Name of the log format \\
  \end{tabular}
\end{table}

\noindent The following is a list of child tags:
\texttt{<value>}, \texttt{<relations>}.

\xmltag{<value>}
This tag contains the actual value of the log format. Value of a log 
format represent set of log messages in the system execution trace 
which have constant and variable parts as described in section (ref) 
This tag does not have any child tags.

\xmltag{<relations>}

This tag contains set of relations, in which the parent log format is 
involved in as the cause log format.
The following is a list of child tags: \texttt{<relation>}.

\xmltag{<relation>}

This tag contains all the details about a particular relation. Such 
as the effect log format and cause-effect variables. There can be 
more than one cause-effect variable pairs. It has the following 
attributes.
\begin{table}[h]
  \begin{tabular}{lcccl}
  \hline
  \textbf{Name} & \textbf{Type} & \textbf{Default Value} & \textbf{Required} & \textbf{Description} \\
  \hline
  effectref & String  & & Yes & The id of the effect log format in this relation \\
  \end{tabular}
\end{table}

\noindent The following is a list of child tags:
\texttt{<causality>}.

\xmltag{<causality>}

This tag represent the relationship between a variable in the 
cause log format and a variable in the effect log format. It has 
the following attributes.
\begin{table}[h]
  \begin{tabular}{lcccl}
  \hline
  \textbf{Name} & \textbf{Type} & \textbf{Default Value} & \textbf{Required} & \textbf{Description} \\
  \hline
  cause & String  & & Yes & The name of the cause variable \\
  effect  & String  & & Yes &  The name of the effect variable \\   
  \end{tabular}
\end{table}

Therefore the elements mentioned above represent the datagraph 
for a partiucar system execution trace. Depending on the QoS 
properties being analyzed a particular system execution trace 
may have more than one datagraphs. These different datagraphs 
may have different log formats and cause-effect relations.

\section{Defining a UNITE Configuration File}

In general the location of the \textit{datagraph file} is specified in the 
\textit{unite file}. Listing~\ref{listing:example.unite} shows a sample 
\textit{unite file}. 

\lstinputlisting[label=listing:example.unite,
  caption=An example configuration file for UNITE.,
  captionpos=b,numbers=left]{analysis/example.unite}

\subsection{UNITE Schema Definition}
\label{sec:unite-scema}

This section discusses the details of the UNITE configuration 
based on its underlying XML Schema Definition.

\xmltag{<cuts:test>}
This is the main tag for the unite configuration document. Its 
XML namespace must have the \url{http://cuts.cs.iupui.edu} definition. If it does
not have this definition, then UNITE will not execute further.

\xmltag{<name>}

This tag contains the name of the unite file. This tag does not have 
any child tags.

\xmltag{<datagraph>}

This tag specify the location of the associated datagraph for the 
QoS analysis. This tag has the following attributes.

\begin{table}[h]
  \begin{tabular}{lcccl}
  \hline
  \textbf{Name} & \textbf{Type} & \textbf{Default Value} & \textbf{Required} & \textbf{Description} \\
  \hline
  location & String  & & Yes & The location of the datagraph configuration file. \\
  \end{tabular}
\end{table}

This tag does not have any child tags.

\xmltag{<evaluation>}

This tag contains the equation for QoS evaluation. The text inside 
this tag should be written in a certain way. The variables of this 
equation should be specified with the log format it belongs to. The 
dot operator after the log format specified the actual variable. This tag 
does not have any child tags.

\xmltag{<aggregation>}

This tag specifies a function used to convert a dataset to a single 
value. Some examples of aggregation functions are AVERAGE, 
MIN, MAX and SUM. This tag does not have any child tags.

\xmltag{<grouping>}

For a given aggregation function this tag tell how to classify 
datasets that are independent of each other. This is the 
container tag for such grouping items
The following is a list of child tags: \texttt{<groupitem>}. 

\xmltag{<groupitem>}

This tag represent an actual grouping item. The \textit{name} 
attribute specify the grouping item. This attribute consists of 
a particular log format id and a variable name. Their should be a 
\_ between the log format and the variable. This tag has the 
following attributes. 
\begin{table}
 \begin{tabular}{lcccl}
  \hline
  \textbf{Name} & \textbf{Type} & \textbf{Default Value} & \textbf{Required} & \textbf{Description} \\
  \hline
  name & String  & & Yes & The name of the grouping item. \\
  \end{tabular}
\end{table}

\xmltag{<services>}

UNITE has a facility to show the results of QoS analysis using different 
presentation methods such as graphs. There are many different presentation 
softwares available such as Microsoft Excel, Gnuplot. This tag contains the 
set of such services the testers want present the analyzed results. This tag has 
the following child tags:\texttt{<service>}

\xmltag{<service>}

This tag represent a presentation service. In general these presentation services 
are developed externally to UNITE and plugged in via a common interface.
Therefore child tags of this tag gives the details required to load these services 
during the runtime. This tag has the following attributes.

\begin{table}
 \begin{tabular}{lcccl}
  \hline
  \textbf{Name} & \textbf{Type} & \textbf{Default Value} & \textbf{Required} & \textbf{Description} \\
  \hline
  name & String  & & Yes & The name of the grouping item. \\
  \end{tabular}
\end{table}

\noindent The following is a list of child tags:
\texttt{<location>}, \texttt{<classname>}, \texttt{<params>}.

\xmltag{<location>}

This tag specify the location of a presentation service module. UNITE 
will search for this location when it wants to load the presentation 
service. This tag does not have any child tags.

\xmltag{<classname>}

This tag specify the name of the class of the presentation 
service. This tag does not have any child tags.

\xmltag{<params>}

This tag specify the additional parameters required to invoke 
the presentation service. This tag does not have any child tags.

\section{Invoking UNITE}
\label{sec:unite-invoke}

Assuming the CUTS runtime architecture has been built and installed 
correctly, the CUTS UNITE tool is installed at the following 
location:
\begin{lstlisting}
%> $CUTS_ROOT/bin/cuts-unite
\end{lstlisting}
To see a complete list of command-line options, use the following 
command:
\begin{lstlisting}
%> $CUTS_ROOT/bin/cuts-unite --help
\end{lstlisting}

A typical invocation of UNITE tool requires the data file which 
contains the system execution trace and the UNITE configuration 
file discussed above as arguments. The datagraph file location 
is specified inside the UNITE configuration file so it doesn't 
need to be specified as an argument. 
Assuming the configuration discussed above is defined in a file 
named \textit{example.unite},  and the system execution trace is resides 
in a file called \textit{example.cdb} you can run the CUTS UNITE tool with
the configuration via the following command: 
\begin{lstlisting}
%> $CUTS_ROOT/bin/cuts-unite -f example.cdb -c example.unite
\end{lstlisting}