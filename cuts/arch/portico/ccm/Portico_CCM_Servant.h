// -*- C++ -*-

//==============================================================================
/**
 *  @file       Portico_CCM_Servant.h
 *
 *  $Id$
 *
 *  @author     James H. Hill <hillj@cs.iupui.edu>
 *
 *  This file was auto-generated by the iCCM architecture skeleton
 *  generator.
 */
//==============================================================================

#ifndef _PORTICO_CCM_SERVANT_H_
#define _PORTICO_CCM_SERVANT_H_

#include "cuts/arch/ccm/CCM_Servant.h"
#include "ace/Thread_Mutex.h"
#include "ace/Condition_T.h"

#include "Portico_CCM_export.h"

#include "NullFederateAmbassador.hh"
#include "fedtime.hh"

/**
 * @class Portico_CCM_Servant
 *
 * Base class for all Portico servant objects. This class enables
 * the container to send commands to the servant, such as
 * domain-specific configuration information.
 */
class PORTICO_CCM_Export Portico_CCM_Servant :
  public NullFederateAmbassador,
  public CUTS_CCM_Servant
{
public:
  /// Default constructor.
  Portico_CCM_Servant (const char * name);

  /// Destructor.
  virtual ~Portico_CCM_Servant (void);

  /**
   * Configure the servant/federate. This is when the servant notifies
   * the execution of what objects/interactions it will publish and
   * subsribe to.
   */
  virtual int install (const std::string & fed, const std::string & exec) = 0;

  /// Remove the servant.
  virtual void remove (void);

  /**
   * The federate ambassador has discovered a new object in
   * the simulation.
   *
   * @param[in]         obj               New object instance
   * @param[in]         obj_class         Object class type
   * @param[in]         obj_name          Name of the object instance
   */
  virtual void discoverObjectInstance (RTI::ObjectHandle obj,
                                       RTI::ObjectClassHandle obj_class,
                                       const char * obj_name);

  virtual void announceSynchronizationPoint (const char *label,
                                             const char *tag);

  virtual void timeAdvanceGrant (const RTI::FedTime & theTime);

  /// Get a reference to the RTI ambassador
  RTI::RTIambassador & rti_ambassador (void);

  /// Get a reference to the RTI ambassador
  const RTI::RTIambassador & rti_ambassador (void) const;

  /**
   * Advance the simulation by the specified amount of time. Control
   * does not return from this method until the request time amount is
   * granted.
   *
   * @param[in]         amt           Amount to advance time
   */
  void advance_time (const RTIfedTime & amt);

  /// Get current time of the federate. Unfortunately, this cannot
  /// be changed externally. This time changes whenever the federate
  /// ambassador receives a callback from the RTI.
  const RTIfedTime & federate_time (void) const;

  /// Wait for a new object to be discovered. The current thread will
  /// sleep until a new object has been discovered.
  void wait_for_object_discovery (const ACE_Time_Value * tv = 0);

protected:
  /// RTI ambassador for the servant.
  RTI::RTIambassador rtiamb_;

  /// The target execution name.
  std::string execname_;

  /// The federate's current time.
  RTIfedTime federate_time_;

  /// The federate's lookahead time.
  RTIfedTime federate_lookahead_;

  /// The federate's time is advancing.
  bool is_advancing_;

  /// Mutex for the discovery condition object.
  ACE_Thread_Mutex obj_discovery_mutex_;

  /// Condition for discoverying an object.
  ACE_Condition <ACE_Thread_Mutex> obj_discovery_;
};

#if defined (__CUTS_INLINE__)
#include "Portico_CCM_Servant.inl"
#endif

#endif  // !defined _Portico_CCM_SERVANT_H_
