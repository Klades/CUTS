// $Id$

#include "CIAO_Generators.h"

#if !defined (__CUTS_INLINE__)
#include "CIAO_Generators.inl"
#endif

#include "../../BE_Options.h"
#include "../../BE_Impl_Node.h"

#include "../../lang/cpp/Cpp.h"
#include "../../lang/cpp/Component_Impl_Generator.h"
#include "../ccm/Component_Impl_Generator.h"

#include "boost/bind.hpp"
#include <sstream>
#include <algorithm>

#define CUTS_BE_CIAO \
  ACE_Singleton <CUTS_BE_Ciao, ACE_Null_Mutex>::instance ()

#define SVNT_SUFFIX       "_svnt"
#define STUB_SUFFIX       "_stub"
#define SKEL_SUFFIX       "_skel"

#define CLIENT_SUFFIX     "C"
#define SERVER_SUFFIX     "S"

static std::string basename (const std::string & filename)
{
  std::string::size_type npos = filename.find_last_of ("/\\");
  return filename.substr (npos + 1);
}

///////////////////////////////////////////////////////////////////////////////
// CUTS_BE_File_Open_T

void CUTS_BE_File_Open_T <CUTS_BE_Ciao>::
generate (const PICML::ComponentImplementationContainer & container,
          const PICML::MonolithicImplementation & impl)
{
  // Construct the name of the file.
  std::string basename (CUTS_BE_OPTIONS ()->output_directory_);
  basename += "/" + std::string (container.name ());

  std::string source_name = basename + ".cpp";
  std::string header_name = basename + ".h";

  // Open all the files for writing.
  this->ctx_.source_.open (source_name.c_str ());
  this->ctx_.source_formatter_.reset (new CUTS_BE_Ciao::formatter_type (this->ctx_.source_));

  this->ctx_.header_.open (header_name.c_str ());
  this->ctx_.header_formatter_.reset (new CUTS_BE_Ciao::formatter_type (this->ctx_.header_));
}

///////////////////////////////////////////////////////////////////////////////
// CUTS_BE_File_Close_T

void CUTS_BE_File_Close_T <CUTS_BE_Ciao>::
generate (const PICML::ComponentImplementationContainer & container,
          const PICML::MonolithicImplementation & impl)
{
  this->ctx_.header_formatter_.reset ();

  if (this->ctx_.header_.is_open ())
    this->ctx_.header_.close ();

  this->ctx_.source_formatter_.reset ();

  if (this->ctx_.source_.is_open ())
    this->ctx_.source_.close ();
}

///////////////////////////////////////////////////////////////////////////////
// CUTS_BE_Include_File_T

void CUTS_BE_Include_File_T <CUTS_BE_Ciao>::
generate (const std::string & include)
{
  this->ctx_.header_ << CUTS_BE_CPP::include (include);
}

///////////////////////////////////////////////////////////////////////////////
// CUTS_BE_Prologue_T

void CUTS_BE_Prologue_T <CUTS_BE_Ciao>::
generate (const PICML::ComponentImplementationContainer & container,
          const PICML::MonolithicImplementation & impl)
{
  std::string name = container.name ();

  // Generate the hash definition for this file.
  std::string hashdef = "_" + name + "_H_";
  std::transform (hashdef.begin (),
                  hashdef.end (),
                  hashdef.begin (),
                  &::toupper);

  this->ctx_.header_
    << "// -*- C++ -*-" << std::endl
    << std::endl
    << "#ifndef " << hashdef << std::endl
    << "#define " << hashdef << std::endl
    << std::endl
    << "#if !defined (ACE_LACKS_PRAGMA_ONCE)" << std::endl
    << "#pragma once" << std::endl
    << "#endif /* ACE_LACKS_PRAGMA_ONCE */" << std::endl
    << std::endl
    << CUTS_BE_CPP::include ("ace/pre")
    << CUTS_BE_CPP::include (name + "EC")
    << CUTS_BE_CPP::include ("cuts/arch/ccm/CCM_Component_T")
    << std::endl;

  this->ctx_.source_
    << CUTS_BE_CPP::single_line_comment ("This file was generated by:")
    << CUTS_BE_CPP::single_line_comment ("$Id$")
    << std::endl
    << CUTS_BE_CPP::include (name)
    /// @todo We should only include the following header if there are
    ///       are output events (or output ports) for this component.
    ///       Otherwise, we can leave this include out of this source.
    << CUTS_BE_CPP::include ("cuts/arch/ccm/CCM_Events_T")
    << std::endl;
}

///////////////////////////////////////////////////////////////////////////////
// CUTS_BE_Epilogue_T

void CUTS_BE_Epilogue_T <CUTS_BE_Ciao>::
generate (const PICML::ComponentImplementationContainer & container,
          const PICML::MonolithicImplementation & impl)
{
  // Generate the hash definition for this file.
  std::string name (container.name ());
  std::string hashdef = "_" + name + "_H_";
  std::transform (hashdef.begin (),
                  hashdef.end (),
                  hashdef.begin (),
                  &::toupper);

  this->ctx_.header_
    << "#endif  // !defined " << hashdef << std::endl
    << std::endl
    << CUTS_BE_CPP::single_line_comment ("end of auto-generated file")
    << std::endl;

  this->ctx_.source_
    << CUTS_BE_CPP::single_line_comment ("end of auto-generated file")
    << std::endl;
}

///////////////////////////////////////////////////////////////////////////////
// CUTS_BE_Component_Impl_Begin_T

void CUTS_BE_Component_Impl_Begin_T <CUTS_BE_Ciao>::
generate (const PICML::MonolithicImplementation & impl,
          const PICML::Component & component)
{
  // This part of the code generates the header file.
  std::string namespace_name (impl.name ());
  std::string implname (component.name ());

  std::vector <PICML::PeriodicEvent> periodics =
    component.PeriodicEvent_kind_children ();

  if (!periodics.empty ())
    this->ctx_.header_ << CUTS_BE_CPP::include ("cuts/Periodic_Event_T");

  this->ctx_.header_
    << std::endl
    << "namespace " << namespace_name
    << "{";

  //// We need to determine if any of the events sources has a
  //// CUTS::Payload_Event type. This is necessary because we will
  //// have to include a special header.
  ////
  //// @note Checking for a CUTS::Payload_Event should be done by
  ////       the preprocessor.

  typedef std::vector <PICML::OutEventPort> OutEventPort_Set;
  OutEventPort_Set outevents = component.OutEventPort_kind_children ();

  std::for_each (outevents.begin (),
                 outevents.end (),
                 boost::bind (&PICML::OutEventPort::Accept,
                              _1,
                              boost::ref (*this)));

  //for (OutEventPort_Set::iterator iter = outevents.begin ();
  //     iter != outevents.end ();
  //     iter ++)
  //{
  //  PICML::Event event = iter->ref ();
  //  std::string eventtype =
  //    this->scope (event, "::") + (std::string) event.name ();

  //  if (eventtype == "CUTS::Payload_Event")
  //  {
  //    this->out_ << include ("cuts/events_i");
  //    break;
  //  }
  //}

  std::vector <PICML::ProvidedRequestPort> facets =
    component.ProvidedRequestPort_kind_children ();

  std::for_each (facets.begin (),
                 facets.end (),
                 boost::bind (&PICML::ProvidedRequestPort::Accept,
                              _1,
                              boost::ref (*this)));

  std::string destructor = "~" + implname;

  // Construct the name of the executor.
  std::string exec ("CIDL_");
  exec += namespace_name + "::" + implname + "_Exec";

  // Construct the name of the context.
  std::string context (CUTS_BE_CPP::scope (component));
  context += "CCM_" + implname + "_Context";

  std::string basetype ("CUTS_CCM_Component_T < ");
  basetype += exec + ", " + context + " >";

  this->ctx_.header_
    << CUTS_BE_CPP::single_line_comment ("Type definition of the implentation base type")
    << "typedef " << basetype << " " << implname << "_Base;"
    << std::endl
    << "/**" << std::endl
    << " * @class " << implname << std::endl
    << " *" << std::endl
    << " * Implementation of the " << exec << " component executor" << std::endl
    << " */" << std::endl
    << "class " << implname << " :" << std::endl
    << "  public " << implname << "_Base {"
    << "public:" << std::endl
    << CUTS_BE_CPP::single_line_comment ("Type definition of the base component type")
    << "typedef " << implname << "_Base base_type;"
    << std::endl

    // Write the default constructor.
    << CUTS_BE_CPP::single_line_comment ("Default constructor")
    << implname << " (void);"
    << std::endl

    // Write the destructor.
    << CUTS_BE_CPP::single_line_comment ("Destructor")
    << "virtual " << destructor << " (void);"
    << std::endl;

  // This part of the code generates the source file.
  this->ctx_.source_
    << "namespace " << namespace_name
    << "{";

  // This part of the code generates the source file.
  this->ctx_.source_
    << CUTS_BE_CPP::function_header (implname)
    << implname << "::" << implname << " (void)";

  CUTS_BE_CPP::Base_Member_Init base_member_init (this->ctx_.source_);
  PICML::Component (component).Accept (base_member_init);

  this->ctx_.source_
    << "{";

  std::vector <PICML::InEventPort> events = component.InEventPort_kind_children ();
  std::for_each (events.begin (),
                 events.end (),
                 boost::bind (&PICML::InEventPort::Accept,
                              _1,
                              boost::ref (*this)));

  std::for_each (periodics.begin (),
                 periodics.end (),
                 boost::bind (&PICML::PeriodicEvent::Accept,
                              _1,
                              boost::ref (*this)));

  // Finish the constructor.
  this->ctx_.source_
    << "}"
    // Write the destructor's implementation.
    << CUTS_BE_CPP::function_header (destructor)
    << implname << "::" << destructor << " (void)"
    << "{"
    << "}";
}

void CUTS_BE_Component_Impl_Begin_T <CUTS_BE_Ciao>::
Visit_ProvidedRequestPort (const PICML::ProvidedRequestPort & facet)
{
  this->ctx_.header_
    << CUTS_BE_CPP::single_line_comment ("Forward decl.")
    << "class " << facet.name () << "_i;"
    << std::endl;
}

void CUTS_BE_Component_Impl_Begin_T <CUTS_BE_Ciao>::
Visit_OutEventPort (const PICML::OutEventPort & port)
{
  this->ctx_.outevent_mgr_.insert (PICML::OutEventPort (port));
}

///////////////////////////////////////////////////////////////////////////////
// CUTS_BE_Component_Impl_End_T

void CUTS_BE_Component_Impl_End_T <CUTS_BE_Ciao>::
generate (const PICML::MonolithicImplementation & impl,
          const PICML::Component & component)
{
  // This part of the code generates the header file.
  this->ctx_.header_
    << "};"
    << "}";

  // This part of the code generates the source file.
  this->ctx_.source_
    << "}";

  this->ctx_.outevent_mgr_.clear ();
}

void CUTS_BE_Component_Impl_End_T <CUTS_BE_Ciao>::
Visit_InEventPort (const PICML::InEventPort & port)
{
  PICML::Input input = port.dstInput ();
  this->sink_name_ = port.name ();

  if (Udm::null != input)
    input.Accept (*this);
}

void CUTS_BE_Component_Impl_End_T <CUTS_BE_Ciao>::
Visit_PeriodicEvent (const PICML::PeriodicEvent & periodic)
{
  std::string name ("periodic_");
  name += periodic.name ();

  // Configure the periodic event.
  this->ctx_.header_
    << "this->" << name << "_.init (this, &type::" << name << ");"
    << "this->register_object (&this->" << name << "_);";
}

void CUTS_BE_Component_Impl_End_T <CUTS_BE_Ciao>::
Visit_Input (const PICML::Input & input)
{
  PICML::InputAction action = input.dstInput_end ();
  action.Accept (*this);
}

void CUTS_BE_Component_Impl_End_T <CUTS_BE_Ciao>::
Visit_InputAction (const PICML::InputAction & action)
{
  std::vector <PICML::Property> properties = action.Property_kind_children ();

  std::vector <PICML::Property>::const_iterator iter =
    std::find_if (properties.begin (),
                  properties.end (),
                  boost::bind (std::equal_to <std::string> (),
                               "asynchronous",
                               boost::bind (&PICML::Property::name, _1)));

  std::string varname ("push_");
  varname += this->sink_name_ + "_";

  this->ctx_.source_
    << "this->" << varname << ".init (this, "
    << "&type::push_" << this->sink_name_ << "_i);"
    << "this->register_object (&this->" << varname << ");";

  std::for_each (properties.begin (),
                 properties.end (),
                 boost::bind (&PICML::Property::Accept, _1, boost::ref (*this)));
}

void CUTS_BE_Component_Impl_End_T <CUTS_BE_Ciao>::
Visit_Property (const PICML::Property & property)
{
  std::string name (property.name ());

  if (name == "threadCount")
  {
    this->ctx_.source_
      << "this->push_" << name << "_.thread_count ("
      << property.DataValue () << ");";
  }
  else if (name == "threadAffinity")
  {
    this->ctx_.source_
      << "this->push_" << name << "_.affinity_mask ("
      << property.DataValue () << ");";
  }
}

///////////////////////////////////////////////////////////////////////////////
// CUTS_BE_Component_Impl_End_T

void CUTS_BE_Component_Impl_Entrypoint_T <CUTS_BE_Ciao>::
generate (const PICML::MonolithicImplementation & monoimpl,
          const PICML::ComponentImplementationArtifact & artifact)
{
  std::string entrypoint (artifact.EntryPoint ());
  PICML::ImplementationArtifact ia = artifact.ref ();

  // Construct the export macro and export filename.
  std::string export_basename (ia.name ());
  std::string export_macro (export_basename);

  std::transform (export_macro.begin (),
                  export_macro.end (),
                  export_macro.begin (),
                  &toupper);

  this->ctx_.header_
    << CUTS_BE_CPP::include (export_basename + "_export")
    << std::endl
    << CUTS_BE_CPP::function_header (entrypoint)
    << "extern \"C\" " << export_macro << "_Export" << std::endl
    << "::Components::EnterpriseComponent_ptr " << entrypoint << " (void);"
    << std::endl;

  this->ctx_.source_
    << CUTS_BE_CPP::function_header (entrypoint)
    << "::Components::EnterpriseComponent_ptr " << std::endl
    << entrypoint << " (void)"
    << "{"
    << "::Components::EnterpriseComponent_ptr retval =" << std::endl
    << "  ::Components::EnterpriseComponent::_nil ();"
    << std::endl
    << "ACE_NEW_RETURN (retval, " << std::endl
    << "::" << monoimpl.name () << "::";

  PICML::Implements implements = monoimpl.dstImplements ();

  if (Udm::null != implements)
    implements.Accept (*this);

  this->ctx_.source_
    << " ()," << std::endl
    << "::Components::EnterpriseComponent::_nil ());"
    << std::endl
    << "return retval;"
    << "}"
    << std::endl;
}

void CUTS_BE_Component_Impl_Entrypoint_T <CUTS_BE_Ciao>::
Visit_Implements (const PICML::Implements & implements)
{
  PICML::ComponentRef ref = implements.dstImplements_end ();
  PICML::Component component = ref.ref ();

  if (Udm::null != component)
    component.Accept (*this);
}

void CUTS_BE_Component_Impl_Entrypoint_T <CUTS_BE_Ciao>::
Visit_Component (const PICML::Component & component)
{
  this->ctx_.source_
    << component.name ();
}

///////////////////////////////////////////////////////////////////////////////
// CUTS_BE_Environment_Method_Begin_T

void CUTS_BE_Environment_Method_Begin_T <CUTS_BE_Ciao>::
generate (const PICML::MultiInputAction & action)
{
  std::string name (action.name ());
  PICML::Component parent = PICML::Component::Cast (action.parent ());
  std::string parent_name = parent.name ();

  if ("activate" == name)
  {
    this->ctx_.header_
      << "virtual void ccm_activate (void);"
      << std::endl;

    this->ctx_.source_
      << "void " << parent_name << "::ccm_activate (void)"
      << "{";
  }
  else if ("configuration_complete" == name)
  {
    this->ctx_.header_
      << "virtual void configuration_complete (void);"
      << std::endl;

    this->ctx_.source_
      << "void " << parent_name << "::configuration_complete (void)"
      << "{";
  }
  else if ("passivate" == name || "remove" == name)
  {
    this->ctx_.header_
      << "virtual void ccm_" << name << " (void);"
      << std::endl;

    this->ctx_.source_
      << "void " << parent_name << "::ccm_" << name << " (void)"
      << "{"
      << CUTS_BE_CPP::single_line_comment ("pass control to base class first")
      << "this->base_type::ccm_" << name << " ()";
  }
}

///////////////////////////////////////////////////////////////////////////////
// CUTS_BE_Environment_Method_End_T

void CUTS_BE_Environment_Method_End_T <CUTS_BE_Ciao>::
generate (const PICML::MultiInputAction & action)
{
  std::string name (action.name ());
  PICML::Component parent = PICML::Component::Cast (action.parent ());

  if ("activate" == name)
  {
    this->ctx_.source_
      << CUTS_BE_CPP::single_line_comment ("pass control to the base class")
      << "this->base_type::ccm_activate ();"
      << "}";
  }
  else if ("configuration_complete" == name)
  {
    this->ctx_.source_
      << CUTS_BE_CPP::single_line_comment ("pass control to the base class")
      << "this->base_type::configuration_complete ();"
      << "}";
  }
  else if ("passivate" == name || "remove" == name)
  {
    this->ctx_.header_
      << "virtual void ccm_" << name << " (void);"
      << std::endl;

    this->ctx_.source_
      << "void " << name << "::ccm_" << name << " (void)"
      << "{"
      << CUTS_BE_CPP::single_line_comment ("pass control to base class first")
      << "this->base_type::ccm_" << name << " ()";
  }
}

///////////////////////////////////////////////////////////////////////////////
// CUTS_BE_Attribute_Begin_T

void CUTS_BE_Attribute_Begin_T <CUTS_BE_Ciao>::
generate (const PICML::Attribute & attr)
{
  PICML::AttributeMember member = attr.AttributeMember_child ();

  if (Udm::null == member)
    return;

  PICML::MemberType member_type = member.ref ();

  if (Udm::null == member_type)
    return;

  std::string name (attr.name ());
  PICML::Component parent = PICML::Component::Cast (attr.parent ());
  std::string parent_name (parent.name ());

  // This part generates the header information.
  this->ctx_.header_
    << CUTS_BE_CPP::single_line_comment ("attribute setter: " + name)
    << "virtual void " << name << " (";

  CUTS_BE_CCM::In_Type_Generator in_type_header_gen (this->ctx_.header_);
  in_type_header_gen.generate (member_type);

  this->ctx_.header_
    << " " << name << ");"
    << std::endl;

  // This part generates the source information.
  this->ctx_.source_
    << CUTS_BE_CPP::function_header ("attribute setter: " + name)
    << "void " << parent_name << "::" << name << " (";

  CUTS_BE_CCM::In_Type_Generator in_type_source_gen (this->ctx_.source_);
  in_type_source_gen.generate (member_type);

  this->ctx_.source_
    << " " << name << ")"
    << "{";
}

///////////////////////////////////////////////////////////////////////////////
// CUTS_BE_Attribute_End_T

void CUTS_BE_Attribute_End_T <CUTS_BE_Ciao>::
generate (const PICML::Attribute & attr)
{
  PICML::AttributeMember member = attr.AttributeMember_child ();
  if (Udm::null == member)
    return;

  PICML::MemberType type = member.ref ();
  if (Udm::null == type)
    return;

  Uml::Class meta = type.type ();
  std::string attr_name (attr.name ());

  this->ctx_.source_
    << "this->" << attr_name << "_ = ";

  if (meta == PICML::GenericObject::meta)
  {
    // We need to create a duplicate copy of the interface
    // before we store it.
    this->ctx_.source_
      << std::endl
      << "  ::CORBA::Object::_duplicate (" << attr_name << ");";
  }
  else if (meta == PICML::TypeEncoding::meta)
  {
    // We need to create a duplicate copy of the typecode
    // interface before we store it.
    this->ctx_.source_
      << std::endl
      << "  ::CORBA::TypeCode::_duplicate (" << attr_name << ");";
  }
  else
  {
    this->ctx_.source_ << attr_name << ";";
  }

  this->ctx_.source_
    << "}";

  // Make sure we generate the <readonly> variant.
  this->readonly_begin_.generate (attr);
  this->readonly_end_.generate (attr);
}

///////////////////////////////////////////////////////////////////////////////
// CUTS_BE_ReadonlyAttribute_Begin_T

void CUTS_BE_ReadonlyAttribute_Begin_T <CUTS_BE_Ciao>::
generate (const PICML::ReadonlyAttribute & attr)
{
  PICML::AttributeMember member = attr.AttributeMember_child ();
  if (member == Udm::null)
    return;

  PICML::MemberType type = member.ref ();
  if (type == Udm::null)
    return;

  std::string attr_name (attr.name ());
  PICML::Component parent = PICML::Component::Cast (attr.parent ());

  // This part of the code generate to the header file.
  this->ctx_.header_
    << CUTS_BE_CPP::single_line_comment ("attribute getter: " + attr_name)
    << "virtual ";

  CUTS_BE_CCM::Retn_Type_Generator retn_header_gen (this->ctx_.header_);
  retn_header_gen.generate (type);

  this->ctx_.header_
    << " " << attr_name << " (void);"
    << std::endl;

  // This part of the code generate to the source file.
  this->ctx_.source_
    << CUTS_BE_CPP::function_header ("attribute getter: " + attr_name);

  CUTS_BE_CCM::Retn_Type_Generator retn_source_gen (this->ctx_.source_);
  retn_source_gen.generate (type);

  this->ctx_.source_
    << " " << parent.name () << "::" << attr_name << " (void)"
    << "{";
}

///////////////////////////////////////////////////////////////////////////////
// CUTS_BE_ReadonlyAttribute_End_T

void CUTS_BE_ReadonlyAttribute_End_T <CUTS_BE_Ciao>::
generate (const PICML::ReadonlyAttribute & attr)
{
  PICML::AttributeMember member = attr.AttributeMember_child ();

  if (member == Udm::null)
    return;

  PICML::MemberType type = member.ref ();

  if (type == Udm::null)
    return;

  Uml::Class meta = type.type ();
  std::string attr_name (attr.name ());

  // This section of the code write the source file.

  if (meta == PICML::String::meta)
  {
    // Strings are special case. We need to return a duplicate
    // copy of the string, or we will have major problems.
    this->ctx_.source_
      << "::CORBA::String_var s =" << std::endl
      << "  ::CORBA::string_dup (this->"
      << attr_name << "_.c_str ());"
      << "return s._retn ();";
  }
  else if (meta == PICML::GenericValue::meta)
  {
    // We need to create an <Any::_var_type> for temporary
    // storage and give control to the client using the
    // _retn () method.
    this->ctx_.source_
      << "CORBA::Any * temp = 0;"
      << "ACE_NEW_THROW_EX (temp," << std::endl
      << "::CORBA::Any (this->" << attr_name << "_)," << std::endl
      << "::CORBA::NO_MEMORY ());"
      << "return temp;";
  }
  else if (meta == PICML::GenericObject::meta)
  {
    this->ctx_.source_
      << "return ::CORBA::Object::_duplicate (this->"
      << attr_name << "_.in ());";
  }
  else if (meta == PICML::TypeEncoding::meta)
  {
    this->ctx_.source_
      << "return ::CORBA::TypeCode::_duplicate (this->"
      << attr_name << "_.in ());";
  }
  else
  {
    this->ctx_.source_
      << "return this->" << attr.name () << "_;";
  }

  this->ctx_.source_
    << "}";
}


///////////////////////////////////////////////////////////////////////////////
// CUTS_BE_PeriodicEvent_Begin_T

void CUTS_BE_PeriodicEvent_Begin_T <CUTS_BE_Ciao>::
generate (const PICML::PeriodicEvent & periodic)
{
  std::string name = periodic.name ();
  std::string func_name = "periodic_" + name;

  PICML::Component parent (PICML::Component::Cast (periodic.parent ()));
  std::string parent_name (parent.name ());

  this->ctx_.header_
    << CUTS_BE_CPP::single_line_comment ("PeriodicEvent: " + name)
    << "void " << func_name << " (void);"
    << std::endl;

  this->ctx_.source_
    << CUTS_BE_CPP::function_header ("PeriodicEvent: " + name)
    << "void " << parent_name << "::" << func_name << " (void)"
    << "{";
}

///////////////////////////////////////////////////////////////////////////////
// CUTS_BE_PeriodicEvent_End_T

void CUTS_BE_PeriodicEvent_End_T <CUTS_BE_Ciao>::
generate (const PICML::PeriodicEvent & periodic)
{
  this->ctx_.source_
    << "}";
}

///////////////////////////////////////////////////////////////////////////////
// CUTS_BE_InEventPort_Begin_T

void CUTS_BE_InEventPort_Begin_T <CUTS_BE_Ciao>::
generate (const PICML::InEventPort & sink,
          const std::vector <PICML::Property> & properties)
{
  PICML::Event event = sink.ref ();

  if (event == Udm::null)
    return;

  PICML::Component parent = PICML::Component::Cast (sink.parent ());
  std::string parent_name (parent.name ());
  std::string name (sink.name ());
  std::string fq_name (CUTS_BE_CPP::fq_type (event));

  this->ctx_.header_
    << CUTS_BE_CPP::single_line_comment ("sink: " + name)
    << "virtual void push_" << name << " (" << fq_name << " * ev);"
    << std::endl;

  this->ctx_.source_
    << CUTS_BE_CPP::function_header ("sink: " + name)
    << "void " << parent_name << "::push_" << name << " (" << fq_name << " * ev)"
    << "{";
}

///////////////////////////////////////////////////////////////////////////////
// CUTS_BE_InEventPort_End_T

void CUTS_BE_InEventPort_End_T <CUTS_BE_Ciao>::
generate (const PICML::InEventPort & attr,
          const std::vector <PICML::Property> & properties)
{
  this->ctx_.source_
    << "ACE_UNUSED_ARG (ev);"
    << "}";
}

///////////////////////////////////////////////////////////////////////////////
// CUTS_BE_ProvidedRequestPort_Begin_T

void CUTS_BE_ProvidedRequestPort_Begin_T <CUTS_BE_Ciao>::
generate (const PICML::ProvidedRequestPort & facet)
{
  PICML::Object obj = PICML::Object::Cast (facet.ref ());

  if (Udm::null == obj)
    return;

  PICML::Component parent (PICML::Component::Cast (facet.parent ()));
  std::string parent_name (parent.name ());
  std::string scope (CUTS_BE_CPP::scope (obj));
  std::string name (facet.name ());
  std::string func ("get_" + name);

  this->ctx_.header_
    << CUTS_BE_CPP::single_line_comment ("facet: " + name)
    << "virtual " << scope << "CCM_" << name << "_ptr" << std::endl
    << "  " << func << " (void);"
    << std::endl;

  this->ctx_.source_
    << CUTS_BE_CPP::function_header ("facet: " + name)
    << scope << "CCM_" << name << "_ptr" << std::endl
    << "  " << parent_name << "::" << func << " (void)"
    << "{";
}

///////////////////////////////////////////////////////////////////////////////
// CUTS_BE_ProvidedRequestPort_End_T

void CUTS_BE_ProvidedRequestPort_End_T <CUTS_BE_Ciao>::
generate (const PICML::ProvidedRequestPort & port)
{
  PICML::Object obj = PICML::Object::Cast (port.ref ());

  if (obj == Udm::null)
    return;

  std::string obj_scope (CUTS_BE_CPP::scope (obj));
  std::string name (obj.name ());

  this->ctx_.source_
    << "return " << obj_scope << "CCM_" << name << "::_nil ();"
    << "}";
}


///////////////////////////////////////////////////////////////////////////////
// workspace generators

//
// CUTS_BE_Workspace_File_Open_T
//
void
CUTS_BE_Workspace_File_Open_T <CUTS_BE_Ciao>::
generate (const std::string & name)
{
  // Construct the full pathname of the workspace.
  std::string pathname (CUTS_BE_OPTIONS ()->output_directory_);
  pathname += "/" + name + ".mwc";

  // Open the workspace file for writing.
  this->ctx_.workspace_.open (pathname.c_str ());
}

//
// CUTS_BE_Workspace_Begin_T
//
void CUTS_BE_Workspace_Begin_T <CUTS_BE_Ciao>::
generate (const std::string & name)
{
  this->ctx_.workspace_
    << "//==================================================================="
    << std::endl
    << "// Makefile, Project, and Workspace Creator File" << std::endl
    << "//" << std::endl
    << "// This file was generated by" << std::endl
    << "// $Id$" << std::endl
    << "//" << std::endl
    << "// Please do not modify the contents of this file under" << std::endl
    << "// any circumstances. Doing so can result in failure to" << std::endl
    << "// successfully build parts of (or the entire) workspace." << std::endl
    << "//==================================================================="
    << std::endl
    << std::endl
    << "workspace (" << name << ") {" << std::endl
    << "  // -- initialize the includes for the project." << std::endl
    << "  cmdline += -include $CUTS_ROOT/MPC/config \\" << std::endl
    << "             -feature_file $CUTS_ROOT/default.features \\" << std::endl
    << "             -relative PROJECT_ROOT=" << std::endl
    << std::endl;
}

//
// CUTS_BE_Workspace_Project_Include_T <, CUTS_BE_Impl_Node>
//
void
CUTS_BE_Workspace_Project_Include_T <CUTS_BE_Ciao, CUTS_BE_Impl_Node>::
generate (const CUTS_BE_Impl_Node & node)
{
  this->ctx_.workspace_
    << "  " << node.name_ << ".mpc" << std::endl;
}

//
// CUTS_BE_Workspace_Project_Include_T <, CUTS_BE_IDL_Node>
//
void
CUTS_BE_Workspace_Project_Include_T <CUTS_BE_Ciao, CUTS_BE_IDL_Node>::
generate (const CUTS_BE_IDL_Node & node)
{
  this->ctx_.workspace_
    << "  " << node.name_ << "_stub.mpc" << std::endl;
}

//
// CUTS_BE_Workspace_End_T
//
void CUTS_BE_Workspace_End_T <CUTS_BE_Ciao>::
generate (const std::string & name)
{
  this->ctx_.workspace_
    << "}" << std::endl
    << std::endl
    << CUTS_BE_CPP::single_line_comment ("end of auto-generated workspace")
    << std::endl;
}

//
// CUTS_BE_Workspace_File_Close_T
//
void CUTS_BE_Workspace_File_Close_T <CUTS_BE_Ciao>::generate (void)
{
  if (this->ctx_.workspace_.is_open ())
    this->ctx_.workspace_.close ();
}

///////////////////////////////////////////////////////////////////////////////
// project generators [CUTS_BE_Impl_Node]

///////////////////////////////////////////////////////////////////////////////
// CUTS_BE_Project_File_Open_T

void CUTS_BE_Project_File_Open_T <CUTS_BE_Ciao, CUTS_BE_Impl_Node>::
generate (const CUTS_BE_Impl_Node & node)
{
  std::string pathname (CUTS_BE_OPTIONS ()->output_directory_);
  pathname += "/" + node.name_ + ".mpc";

  this->ctx_.project_.open (pathname.c_str ());
}

///////////////////////////////////////////////////////////////////////////////
// CUTS_BE_Project_File_Begin_T

void CUTS_BE_Project_File_Begin_T <CUTS_BE_Ciao, CUTS_BE_Impl_Node>::
generate (const CUTS_BE_Impl_Node &)
{
  this->ctx_.project_
    << CUTS_BE_CPP::single_line_comment ("This project file was generated by")
    << CUTS_BE_CPP::single_line_comment ("$Id$")
    << std::endl;
}

//
// CUTS_BE_Project_Write_T <CUTS_BE_Ciao, CUTS_BE_Impl_Node>
//
void
CUTS_BE_Project_Write_T <CUTS_BE_Ciao, CUTS_BE_Impl_Node>::
generate (const CUTS_BE_Impl_Node & node)
{
  // Let's reset the <visited_nodes_> object, if necessary.
  if (!this->visited_nodes_.empty ())
    this->visited_nodes_.clear ();

  // Generate the executor and servant projects.
  this->generate_skel_project (node);
  this->generate_svnt_project (node);
  this->generate_exec_project (node);
}

//
// generate_exec_project
//
void
CUTS_BE_Project_Write_T <CUTS_BE_Ciao, CUTS_BE_Impl_Node>::
generate_exec_project (const CUTS_BE_Impl_Node & node)
{
  std::string exec_basename = node.exec_artifact_.name ();

  std::string skel_project = node.name_ + SKEL_SUFFIX;
  std::replace (skel_project.begin (), skel_project.end (), '/', '_');
  std::replace (skel_project.begin (), skel_project.end (), '\\', '_');

  // Create the export name for the project.
  std::string exec_export (exec_basename);

  std::transform (exec_export.begin (),
                  exec_export.end (),
                  exec_export.begin (),
                  &toupper);

  // Generate the executor project.
  this->ctx_.project_
    << "project (" << exec_basename
    << ") : cuts_coworker_exec {" << std::endl
    << "  sharedname   = " << exec_basename << std::endl
    << std::endl
    << "  dynamicflags = " << exec_export << "_BUILD_DLL" << std::endl
    << std::endl
    << "  prebuild = perl -- $(ACE_ROOT)/bin/generate_export_file.pl "
    << exec_export << " > $(PROJECT_ROOT)/"
    << exec_basename << "_export.h" << std::endl;

  if (!node.references_.empty ())
  {
    visited_nodes_.clear ();

    this->ctx_.project_
      << "  after += " << skel_project;

    std::for_each (node.references_.begin (),
                   node.references_.end (),
                   boost::bind (&CUTS_BE_Project_Write_T::generate_stub_listing,
                                this,
                                _1));

    this->ctx_.project_
      << std::endl
      << std::endl;

    // Clear the visited nodes so we can iterate over them once
    // more. This time we are generating the libs declaration.
    visited_nodes_.clear ();

    this->ctx_.project_
      << "  libs += " << skel_project;

    std::for_each (node.references_.begin (),
                   node.references_.end (),
                   boost::bind (&CUTS_BE_Project_Write_T::generate_stub_listing,
                                this,
                                _1));

    this->ctx_.project_
      << std::endl
      << std::endl;
  }

  generate_mpc_i (node);

  this->ctx_.project_
    // Generate the source files.
    << "  Source_Files {" << std::endl
    << "    " << node.basename_ << ".cpp" << std::endl
    << "  }" << std::endl
    << std::endl

    // Generate the header files.
    << "  Header_Files {" << std::endl
    << std::endl
    << "  }" << std::endl
    << std::endl
    << "  Inline_Files {" << std::endl
    << std::endl
    << "  }" << std::endl
    << std::endl
    << "  IDL_Files {" << std::endl
    << std::endl
    << "  }" << std::endl
    << "}" << std::endl
    << std::endl;
}

//
// generate_svnt_project
//
void
CUTS_BE_Project_Write_T <CUTS_BE_Ciao, CUTS_BE_Impl_Node>::
generate_svnt_project (const CUTS_BE_Impl_Node & node)
{
  // Construct the names of the servant and skeleton project.
  std::string svnt_project = node.svnt_artifact_.name ();
  std::string skel_project = node.name_ + SKEL_SUFFIX;
  std::replace (skel_project.begin (), skel_project.end (), '/', '_');
  std::replace (skel_project.begin (), skel_project.end (), '\\', '_');

  // Create the export name for the project.
  std::string svnt_export = node.svnt_artifact_.name ();
  std::transform (svnt_export.begin (),
                  svnt_export.end (),
                  svnt_export.begin (),
                  &toupper);

  this->ctx_.project_
    << "project (" << svnt_project << ") : cuts_coworker_svnt {" << std::endl
    << "  sharedname   = " << node.svnt_artifact_.location () << std::endl
    << std::endl
    << "  dynamicflags = " << svnt_export << "_BUILD_DLL" << std::endl
    << std::endl
    << "  prebuild = perl -- $(ACE_ROOT)/bin/generate_export_file.pl "
    << svnt_export << " > $(PROJECT_ROOT)/" << svnt_project << "_export.h" << std::endl
    << std::endl;

  // Generate the STUB dependencies for this node.
  if (!node.references_.empty ())
  {
    this->visited_nodes_.clear ();

    this->ctx_.project_
      << "  after += " << skel_project;

    std::for_each (node.references_.begin (),
                   node.references_.end (),
                   boost::bind (&CUTS_BE_Project_Write_T::generate_stub_listing,
                                this,
                                _1));

    this->ctx_.project_
      << std::endl
      << std::endl;

    // Clear the visited nodes so we can iterate over them once
    // more. This time we are generating the libs declaration.
    this->visited_nodes_.clear ();

    this->ctx_.project_
      << "  libs += " << skel_project;

    std::for_each (node.references_.begin (),
                   node.references_.end (),
                   boost::bind (&CUTS_BE_Project_Write_T::generate_stub_listing,
                                this,
                                _1));

    this->ctx_.project_
      << std::endl
      << std::endl;
  }

  this->ctx_.project_
    // Generate the CIDL files
    << "  CIDL_Files {" << std::endl
    << std::endl
    << "  }" << std::endl
    << std::endl

    // Generate the IDL files
    << "  IDL_Files {" << std::endl
    << std::endl
    << "  }" << std::endl
    << std::endl

    // Generate the source files
    << "  Source_Files {" << std::endl
    << "    " << node.basename_ << "_svnt.cpp" << std::endl
    << "  }" << std::endl
    << std::endl

    // Generate the header files
    << "  Header_Files {" << std::endl
    << std::endl
    << "  }" << std::endl
    << "}" << std::endl
    << std::endl;
}

//
// generate_skel_project
//
void
CUTS_BE_Project_Write_T <CUTS_BE_Ciao, CUTS_BE_Impl_Node>::
generate_skel_project (const CUTS_BE_Impl_Node & node)
{
  // Generator the export file for the CIAO servant project.
  std::string skel_project_name = node.name_ + SKEL_SUFFIX;
  std::string skel_export_file = node.name_ + SKEL_SUFFIX + "_export.h";

  std::replace (skel_project_name.begin (), skel_project_name.end (), '/', '_');
  std::replace (skel_project_name.begin (), skel_project_name.end (), '\\', '_');

  // Create the export name for the project.
  std::string skel_export = skel_project_name;
  std::transform (skel_export.begin (),
                  skel_export.end (),
                  skel_export.begin (),
                  &toupper);

  // Generator the export file for the CIAO servant project.
  std::string svnt_export (node.svnt_artifact_.name ());
  std::string svnt_export_file = svnt_export + "_export.h";

  std::transform (svnt_export.begin (),
                  svnt_export.end (),
                  svnt_export.begin (),
                  &toupper);

  this->ctx_.project_
    << "project (" << skel_project_name
    << ") : cuts_coworker_skel {" << std::endl
    << "  sharedname   = " << skel_project_name << std::endl
    << std::endl
    << "  dynamicflags = " << skel_export << "_BUILD_DLL" << std::endl
    << std::endl
    << "  prebuild = perl -- $(ACE_ROOT)/bin/generate_export_file.pl "
    << skel_export << " > $(PROJECT_ROOT)/" << skel_export_file << std::endl
    << std::endl
    << "  cidlflags -= --" << std::endl
    << "  cidlflags += --svnt-export-macro " << svnt_export << "_Export"
    << " --svnt-export-include " << basename (svnt_export_file) << " --"
    << std::endl << std::endl
    << "  idlflags += -Wb,export_macro=" << skel_export << "_Export \\" << std::endl
    << "              -Wb,export_include=" << basename (skel_export_file)
    << std::endl
    << std::endl;

  // Generate the STUB dependencies for this node.
  if (!node.references_.empty ())
  {
    this->visited_nodes_.clear ();

    this->ctx_.project_
      << "  after +=";

    std::for_each (node.references_.begin (),
                   node.references_.end (),
                   boost::bind (&CUTS_BE_Project_Write_T::generate_stub_listing,
                                this,
                                _1));

    this->ctx_.project_
      << std::endl
      << std::endl;

    // Clear the visited nodes so we can iterate over them once
    // more. This time we are generating the libs declaration.
    this->visited_nodes_.clear ();

    this->ctx_.project_
      << "  libs +=";

    std::for_each (node.references_.begin (),
                   node.references_.end (),
                   boost::bind (&CUTS_BE_Project_Write_T::generate_stub_listing,
                                this,
                                _1));

    this->ctx_.project_
      << std::endl
      << std::endl;
  }

  this->ctx_.project_
    // Generate the CIDL files
    << "  CIDL_Files {" << std::endl
    << "    " << node.basename_ << ".cidl" << std::endl
    << "  }" << std::endl
    << std::endl

    // Generate the IDL files
    << "  IDL_Files {" << std::endl
    << "    " << node.basename_ << "E.idl" << std::endl
    << "  }" << std::endl
    << std::endl

    // Generate the source files
    << "  Source_Files {" << std::endl
    << "    " << node.basename_ << "EC.cpp" << std::endl
    << "  }" << std::endl
    << std::endl

    // Generate the header files
    << "  Header_Files {" << std::endl
    << std::endl
    << "  }" << std::endl
    << "}" << std::endl
    << std::endl;
}

//
// generate_stub_listing
//
void
CUTS_BE_Project_Write_T <CUTS_BE_Ciao, CUTS_BE_Impl_Node>::
generate_stub_listing (const CUTS_BE_IDL_Node * node)
{
  IDL_Node_Set::const_iterator iter = this->visited_nodes_.find (node);

  if (iter != visited_nodes_.end ())
    return;

  visited_nodes_.insert (node);

  this->ctx_.project_
    << " \\" << std::endl
    << "    " << node->basename_ << STUB_SUFFIX;

  std::for_each (node->references_.begin (),
                  node->references_.end (),
                  boost::bind (&CUTS_BE_Project_Write_T::generate_stub_listing,
                               this,
                               _1));
}

//
// genereate_mpc_i
//
void CUTS_BE_Project_Write_T <CUTS_BE_Ciao, CUTS_BE_Impl_Node>::
generate_mpc_i (const CUTS_BE_Impl_Node & node)
{
  this->generate_mpc_values ("includes", node.include_paths_);
  this->generate_mpc_values ("libpaths", node.lib_paths_);
  this->generate_mpc_values ("libs", node.lib_);
}

//
// generate_mpc_values
//
void CUTS_BE_Project_Write_T <CUTS_BE_Ciao, CUTS_BE_Impl_Node>::
generate_mpc_values (const std::string & heading,
                     const CUTS_String_Set & listing)
{
  if (listing.empty ())
    return;

  this->ctx_.project_
    << "  " << heading << " +=";

  for (CUTS_String_Set::const_iterator iter = listing.begin ();
       iter != listing.end ();
       iter ++)
  {
    this->ctx_.project_
      << " \\" << std::endl
      << "    " << iter->c_str ();
  }

  this->ctx_.project_
    << std::endl
    << std::endl;
}

//
// CUTS_BE_Project_File_End_T
//
void
CUTS_BE_Project_File_End_T <CUTS_BE_Ciao, CUTS_BE_Impl_Node>::
generate (const CUTS_BE_Impl_Node & node)
{
  this->ctx_.project_
    << CUTS_BE_CPP::single_line_comment("end of auto-generated project file")
    << std::endl;
}

//
// CUTS_BE_Project_File_Close_T
//
void
CUTS_BE_Project_File_Close_T <CUTS_BE_Ciao, CUTS_BE_Impl_Node>::
generate (void)
{
  if (this->ctx_.project_.is_open ())
    this->ctx_.project_.close ();
}

///////////////////////////////////////////////////////////////////////////////
// project generators [CUTS_BE_IDL_Node]

///////////////////////////////////////////////////////////////////////////////
// CUTS_BE_Project_File_Open_T

void CUTS_BE_Project_File_Open_T <CUTS_BE_Ciao, CUTS_BE_IDL_Node>::
generate (const CUTS_BE_IDL_Node & node)
{
  // Construct the name of the project file.
  std::string pathname (CUTS_BE_OPTIONS ()->output_directory_);
  pathname += "/" + node.name_ + "_stub.mpc";

  // Open the project for writing.
  this->ctx_.project_.open (pathname.c_str ());
}

///////////////////////////////////////////////////////////////////////////////
// CUTS_BE_Project_File_Begin_T

void CUTS_BE_Project_File_Begin_T <CUTS_BE_Ciao, CUTS_BE_IDL_Node>::
generate (const CUTS_BE_IDL_Node &)
{
  this->ctx_.project_
    << CUTS_BE_CPP::single_line_comment ("This project file was generated by")
    << CUTS_BE_CPP::single_line_comment ("$Id$")
    << std::endl;
}

//
// CUTS_BE_Project_Write_T <C>
//
void
CUTS_BE_Project_Write_T <CUTS_BE_Ciao, CUTS_BE_IDL_Node>::
generate (const CUTS_BE_IDL_Node & node)
{
  // Generate the export file for the project.
  std::string stub_name = node.basename_ + STUB_SUFFIX;

  // Construct the export name for the project.
  std::string stub_export = stub_name;
  std::transform (stub_export.begin (),
                  stub_export.end (),
                  stub_export.begin (),
                  &toupper);

  std::string stub_export_macro = stub_export + "_Export";
  std::string stub_export_file = stub_name + "_export.h";

  // Generate the project.
  this->ctx_.project_
    << "project (" << stub_name << ") : cuts_coworker_stub {" << std::endl
    << "  sharedname   = " << stub_name << std::endl
    << std::endl
    << "  dynamicflags = " << stub_export << "_BUILD_DLL" << std::endl
    << std::endl
    << "  prebuild = perl -- $(ACE_ROOT)/bin/generate_export_file.pl "
    << stub_export << " > $(PROJECT_ROOT)/" << stub_export_file << std::endl
    << std::endl
    << "  idlflags += -Wb,export_macro=" << stub_export_macro << " \\" << std::endl
    << "              -Wb,export_include=" << stub_export_file << std::endl;

  if (!node.references_.empty ())
  {
    this->visited_nodes_.clear ();

    // Generate the dependencies for this project. This will be
    // all the client projects of the references for this node.
    this->ctx_.project_
      << std::endl
      << "  after +=";

    std::for_each (node.references_.begin (),
                   node.references_.end (),
                   boost::bind (&CUTS_BE_Project_Write_T::generate_stub_listing,
                                this,
                                _1));

    // Generate the import libraries for this project. This will be
    // all client project of the references for this node. The will
    // also be the same as those specified in the "after" tag.

    visited_nodes_.clear ();

    this->ctx_.project_
      << std::endl
      << std::endl
      << "  libs  +=";

    std::for_each (node.references_.begin (),
                   node.references_.end (),
                   boost::bind (&CUTS_BE_Project_Write_T::generate_stub_listing,
                                this,
                                _1));

    this->ctx_.project_
      << std::endl;
  }

  this->ctx_.project_
    << std::endl
    // Generate the IDL files for this project.
    << "  IDL_Files {" << std::endl
    << "    " << node.basename_ << ".idl" << std::endl
    << "  }" << std::endl
    << std::endl

    // Generate the source files for this project.
    << "  Source_Files {" << std::endl
    << "    " << node.basename_ << SERVER_SUFFIX << ".cpp" << std::endl
    << "    " << node.basename_ << CLIENT_SUFFIX << ".cpp" << std::endl
    << "  }" << std::endl
    << std::endl
    // Generate the header files for this project.
    << "  Header_Files {" << std::endl
    << std::endl
    << "  }" << std::endl
    << "}" << std::endl
    << std::endl;
}

//
// generate_stub_listing
//
void CUTS_BE_Project_Write_T <CUTS_BE_Ciao, CUTS_BE_IDL_Node>::
generate_stub_listing (const CUTS_BE_IDL_Node * node)
{
  IDL_Node_Set::const_iterator iter = visited_nodes_.find (node);

  if (iter == visited_nodes_.end ())
  {
    this->visited_nodes_.insert (node);

    this->ctx_.project_
      << " \\" << std::endl
      << "    " << node->basename_ << STUB_SUFFIX;

    std::for_each (node->references_.begin (),
                   node->references_.end (),
                   boost::bind (&CUTS_BE_Project_Write_T::generate_stub_listing,
                                this,
                                _1));
  }
}

//
// CUTS_BE_Project_File_End_T
//
bool CUTS_BE_Project_File_End_T <CUTS_BE_Ciao, CUTS_BE_IDL_Node>::
generate (const CUTS_BE_IDL_Node & node)
{
  this->ctx_.project_
    << "// end of auto-generated project file" << std::endl;

  return true;
}

//
// CUTS_BE_Project_File_Close_T
//
void CUTS_BE_Project_File_Close_T <
CUTS_BE_Ciao, CUTS_BE_IDL_Node>::generate (void)
{
  if (this->ctx_.project_.is_open ())
    this->ctx_.project_.close ();
}
