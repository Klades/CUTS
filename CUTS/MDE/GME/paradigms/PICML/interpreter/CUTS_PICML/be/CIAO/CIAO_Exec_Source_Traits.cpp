// $Id$

#include "CIAO_Exec_Source_Traits.h"
#include "CIAO_Traits.h"
#include "CIAO_Retn_Type.h"
#include "CIAO_In_Type.h"
#include "CIAO_Var_Type.h"
#include "CIAO_Preprocessor.h"
#include "../BE_Options.h"
#include "boost/bind.hpp"
#include "Uml.h"

#include <sstream>
#include <fstream>
#include <algorithm>

//
// env_table_
//
CUTS_CIAO_Exec_Source_Traits::Environment_Table
CUTS_CIAO_Exec_Source_Traits::env_table_;

//
// CUTS_CIAO_Exec_Source_Traits
//
CUTS_CIAO_Exec_Source_Traits::CUTS_CIAO_Exec_Source_Traits (void)
: skip_action_ (false),
  has_activate_ (false)
{
  if (this->env_table_.empty ())
  {
    this->env_table_.insert (
      Environment_Table::value_type ("activate",
      &CUTS_CIAO_Exec_Source_Traits::write_ccm_activate));

    this->env_table_.insert (
      Environment_Table::value_type ("passivate",
      &CUTS_CIAO_Exec_Source_Traits::write_ccm_passivate));

    this->env_table_.insert (
      Environment_Table::value_type ("remove",
      &CUTS_CIAO_Exec_Source_Traits::write_ccm_remove));
  }
}

//
// ~CUTS_CIAO_Exec_Source_Traits
//
CUTS_CIAO_Exec_Source_Traits::~CUTS_CIAO_Exec_Source_Traits (void)
{

}

//
// open_file
//
bool CUTS_CIAO_Exec_Source_Traits::
open_file (const PICML::ComponentImplementationContainer & container)
{
  if (!CUTS_BE_CIAO_PREPROCESSOR->impls ().find (container.name (), this->node_))
    return false;

  if (this->node_->is_proxy_)
    return false;

  return this->_super::open_file (container);
}

//
// write_prologue
//
void CUTS_CIAO_Exec_Source_Traits::
write_prologue (const PICML::ComponentImplementationContainer & container)
{
  if (!this->out_.is_open ())
    return;

  std::string basename = container.name ();
  size_t index = basename.find_last_of ('/');

  if (index != std::string::npos)
    basename.erase (0, index + 1);

  this->out_
    << single_line_comment ("This file was generated by")
    << single_line_comment ("$Id$")
    << std::endl
    << include (basename + CUTS_BE_OPTIONS ()->exec_suffix_)
    /// @todo We should only include the following header if there are
    ///       are output events (or output ports) for this component.
    ///       Otherwise, we can leave this include out of this source.
    << include ("cuts/CCM_Events_T");
}

//
// write_epilogue
//
void CUTS_CIAO_Exec_Source_Traits::
write_epilogue (const PICML::ComponentImplementationContainer & container)
{

}

//
// write_impl_begin
//
void CUTS_CIAO_Exec_Source_Traits::
write_impl_begin (const PICML::MonolithicImplementation & monoimpl,
                  const PICML::Component & component)
{
  if (!this->out_.is_open ())
    return;

  // Let's get all the event sources and initalize out port
  // manager. There has to be a better way to do this, which
  // I hope to realize in the near future.
  typedef std::vector <PICML::OutEventPort> OutEventPort_Set;
  OutEventPort_Set sources = component.OutEventPort_kind_children ();

  for (OutEventPort_Set::iterator iter = sources.begin ();
       iter != sources.end ();
       iter ++)
  {
    this->outevent_mgr_.insert (*iter);
  }

  this->_super::write_impl_begin (monoimpl, component);
}

//
// write_impl_end
//
void CUTS_CIAO_Exec_Source_Traits::
write_impl_end (const PICML::MonolithicImplementation & monoimpl,
                const PICML::Component & component)
{
  if (!this->out_.is_open ())
    return;

  // Let's write the constructor and destructor for the monolithic
  // implementation of the component.
  this->object_impl_ = (std::string) component.name ();
  std::string destructor = "~" + this->object_impl_;

  this->out_
    << function_header (this->object_impl_)
    << this->object_impl_ << "::" << this->object_impl_ << " (void)";

  // Set the initial value for each variable.
  typedef std::vector <PICML::Variable> Variable_Set;
  Variable_Set variables = component.Variable_children ();

  if (!variables.empty ())
  {
    // Locate the first variable with an initial value.
    Variable_Set::iterator iter =
      std::find_if (variables.begin (), variables.end (),
                    boost::bind (std::not_equal_to <std::string> (),
                                 "",
                                 boost::bind (&PICML::Variable::name, _1)));

    if (iter != variables.end ())
    {
      // Write the initial value of the first variable.
      this->out_ << std::endl
                       << ": " << iter->name () << "_ ("
                       << iter->InitialValue () << ")";

      // Write the initial values of the remaining variables.
      std::for_each (++ iter,
                    variables.end (),
                    boost::bind (&CUTS_CIAO_Exec_Source_Traits::write_variable_initializer,
                                  this,
                                  _1));
    }
  }

  this->out_ << "{";

  // Initialize the event handlers.
  std::for_each (this->asynch_events_.begin (),
                 this->asynch_events_.end (),
                 boost::bind (&CUTS_CIAO_Exec_Source_Traits::write_event_handler_init,
                              this,
                              _1));

  // Initialize the periodic events.
  typedef std::vector <PICML::PeriodicEvent> PeriodicEvent_Set;
  PeriodicEvent_Set periodics = component.PeriodicEvent_kind_children ();

  for (PeriodicEvent_Set::iterator iter = periodics.begin ();
       iter != periodics.end ();
       iter ++)
  {
    std::string name ("periodic_");
    name.append (iter->name ());

    // Configure the periodic event.
    this->out_ << "this->" << name << "_.init (this, &type::" << name << ");"
               << "this->register_object (&this->" << name << "_);";
  }

  // Finish the constructor.
  this->out_ << "}"
             << function_header (destructor)
             << this->object_impl_ << "::" << destructor << " (void)"
             << "{"
             << "}";

  // Clear the listing of output events.
  this->outevent_mgr_.clear ();
  this->asynch_events_.clear ();
  this->has_activate_ = false;
}

//
// write_event_handler_init
//
void CUTS_CIAO_Exec_Source_Traits::
write_event_handler_init (const PICML::InEventPort & port)
{
  std::string name = port.name ();

  std::ostringstream varname;
  varname << "push_" << name << "_";

  this->out_ << "this->" << varname.str () << ".init (this, "
             << "&type::push_" << name << "_i);"
             << "this->register_object (&this->"
             << varname.str () << ");";

  PICML::Input input = port.dstInput ();
  PICML::InputAction action = input.dstInput_end ();

  std::vector <PICML::Property>
    properties = action.Property_kind_children ();

  std::for_each (properties.begin (),
                 properties.end (),
                 boost::bind (&CUTS_CIAO_Exec_Source_Traits::write_event_handler_init_property,
                              this,
                              boost::ref (name),
                              _1));
}

//
// write_event_handler_init_property
//
void CUTS_CIAO_Exec_Source_Traits::
write_event_handler_init_property (const std::string & name,
                                   const PICML::Property & prop)
{
  std::string propname = prop.name ();

  if (propname == "threadCount")
  {
    this->out_ << "this->push_" << name << "_.thread_count ("
               << prop.DataValue () << ");";
  }
  else if (propname == "threadAffinity")
  {
    this->out_ << "this->push_" << name << "_.affinity_mask ("
               << prop.DataValue () << ");";
  }
}

//
// write_ProvidedRequestPort_end
//
void CUTS_CIAO_Exec_Source_Traits::
write_ProvidedRequestPort_end (const PICML::ProvidedRequestPort & facet)
{
  if (!this->out_.is_open ())
    return;

  PICML::Object obj = PICML::Object::Cast (facet.ref ());

  if (obj != Udm::null)
  {
    std::string obj_scope = scope (obj, "::");

    this->out_
      << "return " << obj_scope
      << "CCM_" << obj.name () << "::_nil ();";
  }

  this->_super::write_ProvidedRequestPort_end (facet);
}

//
// write_InEventPort_begin
//
void CUTS_CIAO_Exec_Source_Traits::
write_InEventPort_begin (const PICML::InEventPort & sink,
                         const std::vector <PICML::Property> & properties)
{
  if (!this->out_.is_open ())
    return;

  this->_super::write_InEventPort_begin (sink);

  std::vector <PICML::Property>::const_iterator iter =
    std::find_if (properties.begin (),
                  properties.end (),
                  boost::bind (std::equal_to <std::string> (),
                               "asynchronous",
                               boost::bind (&PICML::Property::name, _1)));

  if (iter != properties.end ())
  {
    PICML::Component component = PICML::Component::Cast (sink.parent ());
    std::string classname = component.name ();

    std::string name = sink.name ();
    PICML::Event event = sink.ref ();

    std::ostringstream method;
    method << "push_" << name << "_i";

    // Make this an asynchronous event handler.
    this->out_ << "this->push_" << name << "_.handle_event (ev);"
               << "}"
               << function_header (method.str ())
               << "void " << classname << "::"
               << method.str () << " (" << scope (event, "::")
               << event.name () << " * ev)"
               << "{";

    this->asynch_events_.insert (sink);
  }
}

//
// write_InEventPort_begin
//
void CUTS_CIAO_Exec_Source_Traits::
write_InEventPort_end (const PICML::InEventPort & sink,
                       const std::vector <PICML::Property> & properties)
{
  if (!this->out_.is_open ())
    return;

  this->out_
    << "ACE_UNUSED_ARG (ev);";

  this->_super::write_InEventPort_end (sink);
}


//
// write_ReadonlyAttribute_begin
//
void CUTS_CIAO_Exec_Source_Traits::
write_ReadonlyAttribute_begin (const PICML::ReadonlyAttribute & attr)
{
  if (!this->out_.is_open ())
    return;

  // Write the class scope resolution.
  this->_super::write_ReadonlyAttribute_begin (attr);

  PICML::AttributeMember member = attr.AttributeMember_child ();
  PICML::MemberType mtype = member.ref ();
  Uml::Class metatype = mtype.type ();

  if (metatype == PICML::String::meta)
  {
    // Strings are special case. We need to return a duplicate
    // copy of the string, or we will have major problems.
    this->out_
      << "::CORBA::String_var s =" << std::endl
      << "  ::CORBA::string_dup (this->"
      << attr.name () << "_.c_str ());"
      << "return s._retn ();";
  }
  else if (metatype == PICML::GenericValue::meta)
  {
    // We need to create an <Any::_var_type> for temporary
    // storage and give control to the client using the
    // _retn () method.
    this->out_
      << "CORBA::Any::_var_type tmp = new ::CORBA::Any (this->"
      << attr.name () << "_);"
      << "return tmp._retn ();";
  }
  else if (metatype == PICML::GenericObject::meta)
  {
    this->out_
      << "return ::CORBA::Object::_duplicate (this->"
      << attr.name () << "_.in ());";
  }
  else if (metatype == PICML::TypeEncoding::meta)
  {
    this->out_
      << "return ::CORBA::TypeCode::_duplicate (this->"
      << attr.name () << "_.in ());";
  }
  else
    this->out_ << "return this->" << attr.name () << "_;";
}

//
// write_Attribute_begin
//
void CUTS_CIAO_Exec_Source_Traits::
write_Attribute_begin (const PICML::Attribute & attr)
{
  if (!this->out_.is_open ())
    return;

  this->_super::write_Attribute_begin (attr);
  this->out_ << "this->" << attr.name () << "_ = ";

  PICML::AttributeMember member = attr.AttributeMember_child ();
  PICML::MemberType mtype = member.ref ();
  Uml::Class metatype = mtype.type ();

  if (metatype == PICML::GenericObject::meta)
  {
    // We need to create a duplicate copy of the interface
    // before we store it.
    this->out_
      << std::endl
      << "  ::CORBA::Object::_duplicate (" << attr.name () << ");";
  }
  else if (metatype == PICML::TypeEncoding::meta)
  {
    // We need to create a duplicate copy of the typecode
    // interface before we store it.
    this->out_
      << std::endl
      << "  ::CORBA::TypeCode::_duplicate (" << attr.name () << ");";
  }
  else
    this->out_ << attr.name () << ";";
}

//
// write_ciao_preactivate
//
void CUTS_CIAO_Exec_Source_Traits::
write_ciao_preactivate (const PICML::Component & component)
{
  if (!this->out_.is_open ())
    return;

  this->_super::write_ciao_preactivate (component);
  this->out_ << "{";
}

//
// write_cmm_activate
//
void CUTS_CIAO_Exec_Source_Traits::
write_ccm_activate (const PICML::Component & component)
{
  if (!this->out_.is_open ())
    return;

  this->_super::write_ccm_activate (component);
  this->out_ << "{";

  this->has_activate_ = true;
}

//
// write_ciao_postactivate
//
void CUTS_CIAO_Exec_Source_Traits::
write_ciao_postactivate (const PICML::Component & component)
{
  if (!this->out_.is_open ())
    return;

  this->_super::write_ciao_postactivate (component);
  this->out_ << "{";
}

//
// write_ccm_passivate
//
void CUTS_CIAO_Exec_Source_Traits::
write_ccm_passivate (const PICML::Component & component)
{
  if (!this->out_.is_open ())
    return;

  this->_super::write_ccm_passivate (component);
  this->out_ << "{";
}

//
// write_ccm_remove
//
void CUTS_CIAO_Exec_Source_Traits::
write_ccm_remove (const PICML::Component & component)
{
  if (!this->out_.is_open ())
    return;

  this->_super::write_ccm_remove (component);
  this->out_ << "{";
}

//
// write_environment_begin
//
void CUTS_CIAO_Exec_Source_Traits::
write_environment_begin (const PICML::Component & component)
{
  if (!this->out_.is_open ())
    return;

  this->_super::write_environment_begin (component);
}

//
// write_environment_method_begin
//
void CUTS_CIAO_Exec_Source_Traits::
write_environment_method_begin (const PICML::MultiInputAction & action)
{
  if (!this->out_.is_open ())
    return;

  // Extract the name of the environment method and the
  // component to which the method belongs.
  std::string name = action.name ();
  PICML::Component component = PICML::Component::Cast (action.parent ());

  // Determine if this is a valid environment method.
  Environment_Table::const_iterator iter = this->env_table_.find (name);

  if (iter != this->env_table_.end ())
  {
    // Call the correct environment method. Then generate the remainder
    // of this method. This means generating the code that will access
    // the activation record for the calling thread.
    (this->*(iter->second)) (component);

    // Determine if this environment action requires us to call the
    // base class before we exit the function.
    if (name == "passivate")
    {
      this->out_ << single_line_comment ("pass control to base class")
                 << "base_type::ccm_" << name << " ();"
                 << std::endl;
    }
  }
  else
  {
    this->out_ << single_line_comment ("ignoring environment method: " + name);
  }
}

//
// write_environment_method_end
//
void CUTS_CIAO_Exec_Source_Traits::
write_environment_method_end (const PICML::MultiInputAction & action)
{
  if (!this->out_.is_open ())
    return;

  std::string name = action.name ();

  // Determine if this environment action requires us to call the
  // base class before we exit the function.
  if (name == "activate" || name == "remove")
  {
    if (name == "activate")
    {
      PICML::Component component = PICML::Component::Cast (action.parent ());
      this->write_cuts_init_objects (component);
    }

    this->out_ << std::endl
               << single_line_comment ("pass control to base class")
               << "base_type::ccm_" << name << " ();";
  }

  this->out_ << "}";
}

//
// write_cuts_init_objects
//
void CUTS_CIAO_Exec_Source_Traits::
write_cuts_init_objects (const PICML::Component & component)
{
  typedef std::vector <PICML::PeriodicEvent> PeriodicEvent_Set;
  PeriodicEvent_Set periodics = component.PeriodicEvent_kind_children ();

  if (periodics.empty ())
    return;

  this->out_ << std::endl
             << single_line_comment ("configure the event generators");

  for (PeriodicEvent_Set::iterator iter = periodics.begin ();
        iter != periodics.end ();
        ++ iter)
  {
    std::string name ("periodic_");
    name.append (iter->name ());

    // Determine the distribution class.
    std::string distro (iter->Distribution ());

    std::transform (distro.begin (),
                    distro.end (),
                    distro.begin (),
                    &::toupper);

    this->out_ << "this->" << name << "_.configure (CUTS_Periodic_Event::PE_"
              << distro << ", " << iter->Hertz () << ");";
  }
}

//
// write_environment_end
//
void CUTS_CIAO_Exec_Source_Traits::
write_environment_end (const PICML::Component & component)
{
  if (!this->out_.is_open ())
    return;

  // Make sure we have an activate method, if necessary.
  std::vector <PICML::PeriodicEvent> periodics;
  periodics = component.PeriodicEvent_kind_children ();

  if (!this->has_activate_ && !periodics.empty ())
  {
    this->write_ccm_activate (component);
    this->write_cuts_init_objects (component);

    this->out_ << std::endl
               << single_line_comment ("pass control to base class")
               << "base_type::ccm_activate ();"
               << "}";
  }

  this->_super::write_environment_end (component);
}

//
// write_action_begin
//
void CUTS_CIAO_Exec_Source_Traits::
write_WorkerAction_begin (const PICML::Worker & parent,
                          const PICML::Action & action)
{
  if (!this->out_.is_open ())
    return;

  this->skip_action_ = false;

  // Now, how are we to log this action. If logging is enabled
  // then we need to invoke the logging method. If not, then we
  // need to invoke the non-logging method.

  PICML::Action action_type =
    const_cast <PICML::Action &> (action).Archetype ();

  this->out_
    << "this->" << action.name () << "_."
    << action_type.name () << " (";

  typedef std::vector <PICML::Property> Property_Set;
  Property_Set args = action_type.Property_kind_children ();

  this->arg_count_ = args.size ();
}

//
// write_action_begin
//
void CUTS_CIAO_Exec_Source_Traits::
write_action_end (void)
{
  if (!this->out_.is_open ())
    return;

  if (!this->skip_action_)
    this->out_ << ");";
}

//
// write_action_property
//
void CUTS_CIAO_Exec_Source_Traits::
write_action_property (const PICML::Property & property)
{
  if (!this->out_.is_open ())
    return;

  // Write the value of the property.
  std::string value = property.DataValue ();
  this->out_ << value;

  // If there are anymore argurments remaining, we need to place a
  // comma separator for the next argument.

  if (this->arg_count_ > 1)
  {
    this->out_ << ", ";
    -- this->arg_count_;
  }
}

//
// write_OutputAction_begin
//
void CUTS_CIAO_Exec_Source_Traits::
write_OutputAction_begin (const PICML::OutputAction & action)
{
  if (!this->out_.is_open ())
    return;

  std::string scoped_name;

  if (this->outevent_mgr_.get_scoped_typename (action.name (), scoped_name))
  {
    // We are going to use a special event for CUTS::Payload_Event. This
    // object will actually create a payload of the correct size with the
    // size () setter method is invoked.
    if (scoped_name == "CUTS::Payload_Event")
      scoped_name += "_i";

    this->out_
      << "CUTS_CCM_Event_T <OBV_" << scoped_name
      << "> __event_" << action.uniqueId () << "__;";

    this->skip_action_ = false;
  }
}

//
// write_OuputAction_Property
//
void CUTS_CIAO_Exec_Source_Traits::
write_OuputAction_Property (const PICML::OutputAction & action,
                            const PICML::Property & property)
{
  this->out_
    << "__event_" << action.uniqueId () << "__->"
    << property.name () << " (" << property.DataValue () << ");";
}

//
// write_OutputAction_begin
//
void CUTS_CIAO_Exec_Source_Traits::
write_OutputAction_end (const PICML::OutputAction & action)
{
  if (!this->out_.is_open ())
    return;

  std::string scoped_name;

  if (!this->skip_action_)
  {
    this->out_
      << "this->ctx_->push_"
      << action.name () << " (__event_" << action.uniqueId () << "__.in ());"
      << std::endl;
  }
}

//
// write_precondition
//
void CUTS_CIAO_Exec_Source_Traits::
write_precondition (const std::string & precondition)
{
  if (!this->out_.is_open ())
    return;

  this->out_
    << "if (" << precondition << ")" << std::endl;
}

//
// write_precondition
//
void CUTS_CIAO_Exec_Source_Traits::
write_postcondition (const std::string & postcondition)
{
  if (!this->out_.is_open ())
    return;

  this->out_ << postcondition;
}


//
// write_method_begin
//
void CUTS_CIAO_Exec_Source_Traits::
write_PeriodicEvent_begin (const PICML::PeriodicEvent & periodic)
{
  if (!this->out_.is_open ())
    return;

  this->_super::write_PeriodicEvent_begin (periodic);
}

//
// write_PeriodicEvent_end
//
void CUTS_CIAO_Exec_Source_Traits::
write_PeriodicEvent_end (const PICML::PeriodicEvent & periodic)
{
  this->out_
    << "}";
}

//
// write_branches_begin
//
void CUTS_CIAO_Exec_Source_Traits::write_branches_begin (size_t branches)
{
  this->branches_.push (1);
}

//
// write_branch_condition_begin
//
void CUTS_CIAO_Exec_Source_Traits::write_branch_condition_begin (void)
{
  // We need to generate an "else if" statement if this is not
  // the first transition.
  if (!this->branches_.empty () && this->branches_.top () ++ > 1)
  {
    this->out_ << "else ";
  }

  this->out_ << "if (";
}

//
// write_branch_condition_end
//
void CUTS_CIAO_Exec_Source_Traits::
write_branch_condition_end (void)
{
  this->out_ << ")" << std::endl;
}

//
// write_branch_else_condition
//
void CUTS_CIAO_Exec_Source_Traits::
write_branch_else_condition (void)
{
  this->out_ << "else" << std::endl;
}

//
// write_branch_begin
//
void CUTS_CIAO_Exec_Source_Traits::write_branch_begin (void)
{
  this->out_ << "{";
}

//
// write_branch_begin
//
void CUTS_CIAO_Exec_Source_Traits::write_branch_end (void)
{
  this->out_ << "}";
}

//
// write_branches_end
//
void CUTS_CIAO_Exec_Source_Traits::write_branches_end (void)
{
  this->branches_.pop ();
}

//
// write_equal_to
//
void CUTS_CIAO_Exec_Source_Traits::write_equal_to (void)
{
  this->out_ << " == ";
}

//
// write_not_equal_to
//
void CUTS_CIAO_Exec_Source_Traits::write_not_equal_to (void)
{
  this->out_ << " != ";
}

//
// write_less_than
//
void CUTS_CIAO_Exec_Source_Traits::write_less_than (void)
{
  this->out_ << " < ";
}

//
// write_less_than_equal_to
//
void CUTS_CIAO_Exec_Source_Traits::write_less_than_equal_to (void)
{
  this->out_ << " <= ";
}

//
// write_greater_than
//
void CUTS_CIAO_Exec_Source_Traits::write_greater_than (void)
{
  this->out_ << " > ";
}

//
// write_greater_than_equal_to
//
void CUTS_CIAO_Exec_Source_Traits::write_greater_than_equal_to (void)
{
  this->out_ << " >= ";
}

//
// write_identifier
//
void CUTS_CIAO_Exec_Source_Traits::
write_identifier (const std::string & ident)
{
  this->out_ << ident << "_";
}

//
// write_text
//
void CUTS_CIAO_Exec_Source_Traits::write_text (const std::string & text)
{
  this->out_ << text;
}

//
// write_char
//
void CUTS_CIAO_Exec_Source_Traits::write_char (char ch)
{
  this->out_ << ch;
}

//
// write_and_symbol
//
void CUTS_CIAO_Exec_Source_Traits::write_and_symbol (void)
{
  this->out_ << " && ";
}

//
// write_or_symbol
//
void CUTS_CIAO_Exec_Source_Traits::write_or_symbol (void)
{
  this->out_ << " || ";
}

//
// write_variable_initializer
//
void CUTS_CIAO_Exec_Source_Traits::
write_variable_initializer (const PICML::Variable & variable)
{
  std::string value = variable.InitialValue ();

  if (!value.empty ())
  {
    this->out_ << "," << std::endl
                     << "  " << variable.name () << "_ ("
                     << variable.InitialValue () << ")";
  }
}
