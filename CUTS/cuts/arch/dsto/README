$Id$

This is a first cut at a stripped-down CIAO framework to be
used for adapting CIAO components to exchange data by means
of regular CCM events, DDS, or tcp/ip. This design is not
intended to be spec-compliant in any way. Some of the code
consists of alternate base classes for servants, contexts,
event consumers, and executors, with support for unnecessary
features (facets, receptacles, attributes, homes) removed.
There are also methods for conversion of basic native data
types to basic CORBA types and vice versa. It is assumed that
existing applications will be modified to becomes executors
by inheriting the appropriate base class and implementing a
few methods specific to the most derived type.

          BUILDS IN THIS DIRECTORY

DSTO_Utilities
  Library containing the code descibed above.

ModelData
  Library built from code generated by a GME model interpreter,
  containing an IDL file of data types mapped from the native
  application data types, as well as conversion code specific
  to these data types, using the basic type conversion code in
  DSTO_Utilities. For convenience, a header file containing
  the application data types is included in this build.
  
PubApp, SubApp
  2 libraries containing the modified application code and
  associated context classes generated from the model. Since
  the normal CCM executor IDL has been eliminated, the generated
  context classes inherit from the DSTO_Utilties context base
  class directly (and indirectly from SessionContext) and are
  included in this build as the simplest way to avoid circular
  dependencies. These libs correspond to the CAIO *_exec libs.
  
PubAppAdapter, SubAppAdapter
  2 libraries containing IDL generated from the model that
  represents the mapping of an application class to a CCM component,
  with the application's operations mapped to 'publishes' and
  'consumes' ports. A class named *Adapter is also contained
  in each lib, corresponding to the CIAO *_svnt class. These
  classes are also generated from the model. These libs 
  correspond to a combination of the CIAO *_stub and *_svnt
  libs.
  
Driver
  An executable that runs a simple example. Code from CIAO's
  NodeApplication_Impl is pasted in to spawn a component server,
  create containers and install their corresponding components
  without using a DAnCE or a deployment plan (a deployment plan
  will ultimately be generated from the model however). The
  driver uses the object references returned for the installed
  components to simulate the formation of a connection by (1)
  getting an event consumer from the subscribing component and
  passing it to the subscribe() call on the publishing
  component. Instead of creating a separate IDL operation to
  trigger the event passing, the configuration_complete()
  method of the publishing component (not used by CIAO) has
  simply been overridden to instantiate the native data type
  (in this example, a nested struct), populate it, and pass
  it to the context method, from where it will follow the usual
  CCM call chain. Note that the generated context methods for
  event source and sink ports use the native data type, unlike
  CIAO, converting the argument to the corresponding CORBA
  type before iterating over the stored event consumers. In
  the subscriber's event consumer, the received CORBA event
  is converted back to the native type and passed to the
  'executor" (application).
  
          NAMING CONVENTIONS
          
Attention has been paid to the names of generated classes,
methods and IDL types to make it easy for a model interpreter
to construct them from the corresponding native identifiers.

          KNOWN PROBLEMS AND TO-DO
          
The driver executes no cleanup of components, containers or the
component server. This cleanup may be added later or it may
wait until the creation of an example that uses DAnCE and a
deployment plan to handle it automatically.

There is problem with the current (homeless) creation of the
executor. At some point, the member that stores the context
reference is over-written and corrupted, after the 
set_session_context() call is made from the servant constructor.
There also seems to be a problem with the executor's virtual
function table To work around this problem for now, a non-virtual
method set_context() has been added to the executor, and this
is called in configuration_complete() just before the call to
the push_* method, making sure that the executor's context is
a valid pointer.

There are some class member heap allocations that need to have
their memory managed at some point.

          FURTHER DEVELOPMENT
          
We plan to implement support for DDS and tcp/ip data passing
by coming up with alternative implementations for the existing
operations corresponding to CCM event source and sink ports.
As with the implementation in the present example, this code
will be generated by a model interpreter. Which version will
be generated is to be controlled by model annotations.         