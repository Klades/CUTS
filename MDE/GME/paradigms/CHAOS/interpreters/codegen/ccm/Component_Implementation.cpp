// $Id$

#include "StdAfx.h"
#include "Component_Implementation.h"

#if !defined (__CUTS_INLINE__)
#include "Component_Implementation.inl"
#endif

#include "../BE_Options.h"
#include "../cpp/Component_Impl_Generator.h"
#include "boost/bind.hpp"
#include "Uml.h"

///////////////////////////////////////////////////////////////////////////////
// CUTS_BE_File_Open_T

void CUTS_BE_File_Open_T <CUTS_BE_CCM::Cpp::Context>::
generate (const CHAOS::ComponentImplementationContainer & container,
          const CHAOS::MonolithicImplementation & impl)
{
  // Construct the name of the file.
  std::string basename (CUTS_BE_OPTIONS ()->output_directory_);
  basename += "/" + std::string (impl.name ());

  std::string source_name = basename + ".cpp";
  std::string header_name = basename + ".h";

  // Open all the files for writing.
  this->ctx_.source_.open (source_name.c_str ());
  this->ctx_.source_formatter_.reset (new CUTS_BE_CCM::Cpp::Context::formatter_type (this->ctx_.source_));

  this->ctx_.header_.open (header_name.c_str ());
  this->ctx_.header_formatter_.reset (new CUTS_BE_CCM::Cpp::Context::formatter_type (this->ctx_.header_));
}

///////////////////////////////////////////////////////////////////////////////
// CUTS_BE_File_Close_T

void CUTS_BE_File_Close_T <CUTS_BE_CCM::Cpp::Context>::
generate (const CHAOS::ComponentImplementationContainer & container,
          const CHAOS::MonolithicImplementation & impl)
{
  this->ctx_.header_formatter_.reset ();

  if (this->ctx_.header_.is_open ())
    this->ctx_.header_.close ();

  this->ctx_.source_formatter_.reset ();

  if (this->ctx_.source_.is_open ())
    this->ctx_.source_.close ();
}

///////////////////////////////////////////////////////////////////////////////
// CUTS_BE_Include_File_T

void CUTS_BE_Include_File_T <CUTS_BE_CCM::Cpp::Context>::
generate (const std::string & include)
{
  this->ctx_.header_ << CUTS_BE_CPP::include (include);
}

///////////////////////////////////////////////////////////////////////////////
// CUTS_BE_Prologue_T

void CUTS_BE_Prologue_T <CUTS_BE_CCM::Cpp::Context>::
generate (const CHAOS::ComponentImplementationContainer & container,
          const CHAOS::MonolithicImplementation & impl)
{
  std::string name (impl.name ());

  // Generate the hash definition for this file.
  std::string hashdef = "_" + name + "_H_";
  std::transform (hashdef.begin (),
                  hashdef.end (),
                  hashdef.begin (),
                  &::toupper);

  this->ctx_.header_
    << "// -*- C++ -*-" << std::endl
    << std::endl
    << "#ifndef " << hashdef << std::endl
    << "#define " << hashdef << std::endl
    << std::endl
    << "#if !defined (ACE_LACKS_PRAGMA_ONCE)" << std::endl
    << "#pragma once" << std::endl
    << "#endif /* ACE_LACKS_PRAGMA_ONCE */" << std::endl
    << std::endl
    << CUTS_BE_CPP::include ("ace/pre")
    << CUTS_BE_CPP::include (std::string (container.name ()) + "EC")
    << CUTS_BE_CPP::include ("cuts/arch/ccm/CCM_Component_T")
    << std::endl;

  this->ctx_.source_
    << CUTS_BE_CPP::single_line_comment ("This file was generated by:")
    << CUTS_BE_CPP::single_line_comment ("$Id$")
    << std::endl
    << CUTS_BE_CPP::include (name)
    /// @todo We should only include the following header if there are
    ///       are output events (or output ports) for this component.
    ///       Otherwise, we can leave this include out of this source.
    << CUTS_BE_CPP::include ("cuts/arch/ccm/CCM_Events_T")
    << std::endl;
}

///////////////////////////////////////////////////////////////////////////////
// CUTS_BE_Epilogue_T

void CUTS_BE_Epilogue_T <CUTS_BE_CCM::Cpp::Context>::
generate (const CHAOS::ComponentImplementationContainer & container,
          const CHAOS::MonolithicImplementation & impl)
{
  // Generate the hash definition for this file.
  std::string name (container.name ());
  std::string hashdef = "_" + name + "_H_";
  std::transform (hashdef.begin (),
                  hashdef.end (),
                  hashdef.begin (),
                  &::toupper);

  this->ctx_.header_
    << CUTS_BE_CPP::include ("ace/post")
    << std::endl
    << "#endif  // !defined " << hashdef << std::endl
    << std::endl
    << CUTS_BE_CPP::single_line_comment ("end of auto-generated file")
    << std::endl;

  this->ctx_.source_
    << CUTS_BE_CPP::single_line_comment ("end of auto-generated file")
    << std::endl;
}

///////////////////////////////////////////////////////////////////////////////
// CUTS_BE_Component_Impl_Begin_T

void CUTS_BE_Component_Impl_Begin_T <CUTS_BE_CCM::Cpp::Context>::
generate (const CHAOS::MonolithicImplementation & impl,
          const CHAOS::Component & component)
{
  // This part of the code generates the header file.
  std::string namespace_name (impl.name ());
  std::string implname (component.name ());

  std::vector <CHAOS::PeriodicEvent> periodics =
    component.PeriodicEvent_kind_children ();

  if (!periodics.empty ())
    this->ctx_.header_ << CUTS_BE_CPP::include ("cuts/Periodic_Event_T");

  this->ctx_.header_
    << std::endl
    << "namespace " << namespace_name
    << "{";

  //// We need to determine if any of the events sources has a
  //// CUTS::Payload_Event type. This is necessary because we will
  //// have to include a special header.
  ////
  //// @note Checking for a CUTS::Payload_Event should be done by
  ////       the preprocessor.

  typedef std::vector <CHAOS::OutEventPort> OutEventPort_Set;
  OutEventPort_Set outevents = component.OutEventPort_kind_children ();

  for (auto outevent : outevents)
    outevent.Accept (*this);

  //for (OutEventPort_Set::iterator iter = outevents.begin ();
  //     iter != outevents.end ();
  //     iter ++)
  //{
  //  CHAOS::Event event = iter->ref ();
  //  std::string eventtype =
  //    this->scope (event, "::") + (std::string) event.name ();

  //  if (eventtype == "CUTS::Payload_Event")
  //  {
  //    this->out_ << include ("cuts/events_i");
  //    break;
  //  }
  //}

  std::vector <CHAOS::ProvidedRequestPort> facets =
    component.ProvidedRequestPort_kind_children ();

  for (auto facet : facets)
    facet.Accept (*this);

  std::string destructor = "~" + implname;

  // Construct the name of the executor.
  std::string exec =
    "CIAO_" + CUTS_BE_CPP::fq_type (component, "_", false) +
    "_Impl::" + implname + "_Exec";

  // Construct the name of the context.
  std::string context (CUTS_BE_CPP::scope (component));
  context += "CCM_" + implname + "_Context";

  std::string basetype ("CUTS_CCM_Component_T < ");
  basetype += exec + ", " + context + " >";

  this->ctx_.header_
    << CUTS_BE_CPP::single_line_comment ("Type definition of the implentation base type")
    << "typedef " << basetype << " " << implname << "_Base;"
    << std::endl
    << "/**" << std::endl
    << " * @class " << implname << std::endl
    << " *" << std::endl
    << " * Implementation of the " << exec << " component executor" << std::endl
    << " */" << std::endl
    << "class " << implname << " :" << std::endl
    << "  public " << implname << "_Base {"
    << "public:" << std::endl
    << CUTS_BE_CPP::single_line_comment ("Type definition of the base component type")
    << "typedef " << implname << "_Base base_type;"
    << std::endl

    // Write the default constructor.
    << CUTS_BE_CPP::single_line_comment ("Default constructor")
    << implname << " (void);"
    << std::endl

    // Write the destructor.
    << CUTS_BE_CPP::single_line_comment ("Destructor")
    << "virtual " << destructor << " (void);"
    << std::endl;

  // This part of the code generates the source file.
  this->ctx_.source_
    << "namespace " << namespace_name
    << "{";

  // This part of the code generates the source file.
  this->ctx_.source_
    << CUTS_BE_CPP::function_header (implname)
    << implname << "::" << implname << " (void)";

  CUTS_BE_CPP::Base_Member_Init base_member_init (this->ctx_.source_);
  CHAOS::Component (component).Accept (base_member_init);

  this->ctx_.source_
    << "{";

  std::vector <CHAOS::InEventPort> events = component.InEventPort_kind_children ();
  for (auto event : events)
    event.Accept (*this);

  CUTS_BE_CPP::Initialize_Entity entity (this->ctx_.source_);
  for (auto periodic : periodics)
    periodic.Accept (entity);

  // Finish the constructor.
  this->ctx_.source_
    << "}"
    // Write the destructor's implementation.
    << CUTS_BE_CPP::function_header (destructor)
    << implname << "::" << destructor << " (void)"
    << "{"
    << "}";
}

void CUTS_BE_Component_Impl_Begin_T <CUTS_BE_CCM::Cpp::Context>::
Visit_ProvidedRequestPort (const CHAOS::ProvidedRequestPort & facet)
{
  this->ctx_.header_
    << CUTS_BE_CPP::single_line_comment ("Forward decl.")
    << "class " << facet.name () << "_i;"
    << std::endl;
}

void CUTS_BE_Component_Impl_Begin_T <CUTS_BE_CCM::Cpp::Context>::
Visit_OutEventPort (const CHAOS::OutEventPort & port)
{
  this->ctx_.outevent_mgr_.insert (CHAOS::OutEventPort (port));
}

///////////////////////////////////////////////////////////////////////////////
// CUTS_BE_Component_Impl_End_T

void CUTS_BE_Component_Impl_End_T <CUTS_BE_CCM::Cpp::Context>::
generate (const CHAOS::MonolithicImplementation & impl,
          const CHAOS::Component & component)
{
  // This part of the code generates the header file.
  this->ctx_.header_
    << "};"
    << "}";

  // This part of the code generates the source file.
  this->ctx_.source_
    << "}";

  this->ctx_.outevent_mgr_.clear ();
}

void CUTS_BE_Component_Impl_End_T <CUTS_BE_CCM::Cpp::Context>::
Visit_InEventPort (const CHAOS::InEventPort & port)
{
  CHAOS::Input input = port.dstInput ();
  this->sink_name_ = port.name ();

  if (Udm::null != input)
    input.Accept (*this);
}

void CUTS_BE_Component_Impl_End_T <CUTS_BE_CCM::Cpp::Context>::
Visit_PeriodicEvent (const CHAOS::PeriodicEvent & periodic)
{
  std::string name ("periodic_");
  name += periodic.name ();

  // Configure the periodic event.
  this->ctx_.header_
    << "this->" << name << "_.init (this, &type::" << name << ");"
    << "this->register_object (&this->" << name << "_);";
}

void CUTS_BE_Component_Impl_End_T <CUTS_BE_CCM::Cpp::Context>::
Visit_Input (const CHAOS::Input & input)
{
  CHAOS::InputAction action = input.dstInput_end ();
  action.Accept (*this);
}

void CUTS_BE_Component_Impl_End_T <CUTS_BE_CCM::Cpp::Context>::
Visit_InputAction (const CHAOS::InputAction & action)
{
  std::vector <CHAOS::Property> properties = action.Property_kind_children ();

  std::vector <CHAOS::Property>::const_iterator iter =
    std::find_if (properties.begin (),
                  properties.end (),
                  boost::bind (std::equal_to <std::string> (),
                               "asynchronous",
                               boost::bind (&CHAOS::Property::name, _1)));

  std::string varname ("push_");
  varname += this->sink_name_ + "_";

  this->ctx_.source_
    << "this->" << varname << ".init (this, "
    << "&type::push_" << this->sink_name_ << "_i);"
    << "this->register_object (&this->" << varname << ");";

  for (auto property : properties)
    property.Accept (*this);
}

void CUTS_BE_Component_Impl_End_T <CUTS_BE_CCM::Cpp::Context>::
Visit_Property (const CHAOS::Property & property)
{
  std::string name (property.name ());

  if (name == "threadCount")
  {
    this->ctx_.source_
      << "this->push_" << name << "_.thread_count ("
      << property.DataValue () << ");";
  }
  else if (name == "threadAffinity")
  {
    this->ctx_.source_
      << "this->push_" << name << "_.affinity_mask ("
      << property.DataValue () << ");";
  }
}

///////////////////////////////////////////////////////////////////////////////
// CUTS_BE_Component_Impl_End_T

void CUTS_BE_Component_Impl_Entrypoint_T <CUTS_BE_CCM::Cpp::Context>::
generate (const CHAOS::MonolithicImplementation & monoimpl,
          const CHAOS::ComponentImplementationArtifact & artifact)
{
  std::string entrypoint (artifact.EntryPoint ());
  CHAOS::ImplementationArtifact ia = artifact.ref ();

  // Construct the export macro and export filename.
  std::string export_basename (ia.name ());
  std::string export_macro (export_basename);

  std::transform (export_macro.begin (),
                  export_macro.end (),
                  export_macro.begin (),
                  &toupper);

  this->ctx_.header_
    << CUTS_BE_CPP::include (export_basename + "_export")
    << std::endl
    << CUTS_BE_CPP::function_header (entrypoint)
    << "extern \"C\" " << export_macro << "_Export" << std::endl
    << "::Components::EnterpriseComponent_ptr " << entrypoint << " (void);"
    << std::endl;

  this->ctx_.source_
    << CUTS_BE_CPP::function_header (entrypoint)
    << "::Components::EnterpriseComponent_ptr " << std::endl
    << entrypoint << " (void)"
    << "{"
    << "::Components::EnterpriseComponent_ptr retval =" << std::endl
    << "  ::Components::EnterpriseComponent::_nil ();"
    << std::endl
    << "ACE_NEW_RETURN (retval, " << std::endl
    << "::" << monoimpl.name () << "::";

  CHAOS::Implements implements = monoimpl.dstImplements ();

  if (Udm::null != implements)
    implements.Accept (*this);

  this->ctx_.source_
    << " ()," << std::endl
    << "::Components::EnterpriseComponent::_nil ());"
    << std::endl
    << "return retval;"
    << "}"
    << std::endl;
}

void CUTS_BE_Component_Impl_Entrypoint_T <CUTS_BE_CCM::Cpp::Context>::
Visit_Implements (const CHAOS::Implements & implements)
{
  CHAOS::ComponentRef ref = implements.dstImplements_end ();
  CHAOS::Component component = ref.ref ();

  if (Udm::null != component)
    component.Accept (*this);
}

void CUTS_BE_Component_Impl_Entrypoint_T <CUTS_BE_CCM::Cpp::Context>::
Visit_Component (const CHAOS::Component & component)
{
  this->ctx_.source_
    << component.name ();
}

///////////////////////////////////////////////////////////////////////////////
// CUTS_BE_Environment_Method_Begin_T

void CUTS_BE_Environment_Method_Begin_T <CUTS_BE_CCM::Cpp::Context>::
generate (const CHAOS::MultiInputAction & action)
{
  std::string name (action.name ());
  CHAOS::Component parent = CHAOS::Component::Cast (action.parent ());
  std::string parent_name = parent.name ();

  if ("activate" == name)
  {
    this->ctx_.header_
      << "virtual void ccm_activate (void);"
      << std::endl;

    this->ctx_.source_
      << "void " << parent_name << "::ccm_activate (void)"
      << "{";
  }
  else if ("configuration_complete" == name)
  {
    this->ctx_.header_
      << "virtual void configuration_complete (void);"
      << std::endl;

    this->ctx_.source_
      << "void " << parent_name << "::configuration_complete (void)"
      << "{";
  }
  else if ("passivate" == name || "remove" == name)
  {
    this->ctx_.header_
      << "virtual void ccm_" << name << " (void);"
      << std::endl;

    this->ctx_.source_
      << "void " << parent_name << "::ccm_" << name << " (void)"
      << "{"
      << CUTS_BE_CPP::single_line_comment ("pass control to base class first")
      << "this->base_type::ccm_" << name << " ()";
  }
}

///////////////////////////////////////////////////////////////////////////////
// CUTS_BE_Environment_Method_End_T

void CUTS_BE_Environment_Method_End_T <CUTS_BE_CCM::Cpp::Context>::
generate (const CHAOS::MultiInputAction & action)
{
  std::string name (action.name ());
  CHAOS::Component parent = CHAOS::Component::Cast (action.parent ());

  if ("activate" == name)
  {
    this->ctx_.source_
      << CUTS_BE_CPP::single_line_comment ("pass control to the base class")
      << "this->base_type::ccm_activate ();"
      << "}";
  }
  else if ("configuration_complete" == name)
  {
    this->ctx_.source_
      << CUTS_BE_CPP::single_line_comment ("pass control to the base class")
      << "this->base_type::configuration_complete ();"
      << "}";
  }
  else if ("passivate" == name || "remove" == name)
  {
    this->ctx_.header_
      << "virtual void ccm_" << name << " (void);"
      << std::endl;

    this->ctx_.source_
      << "void " << name << "::ccm_" << name << " (void)"
      << "{"
      << CUTS_BE_CPP::single_line_comment ("pass control to base class first")
      << "this->base_type::ccm_" << name << " ()";
  }
}

///////////////////////////////////////////////////////////////////////////////
// CUTS_BE_Attribute_Begin_T

void CUTS_BE_Attribute_Begin_T <CUTS_BE_CCM::Cpp::Context>::
generate (const CHAOS::Attribute & attr)
{
  CHAOS::AttributeMember member = attr.AttributeMember_child ();

  if (Udm::null == member)
    return;

  CHAOS::MemberType member_type = member.ref ();

  if (Udm::null == member_type)
    return;

  std::string name (attr.name ());
  CHAOS::Component parent = CHAOS::Component::Cast (attr.parent ());
  std::string parent_name (parent.name ());

  // This part generates the header information.
  this->ctx_.header_
    << CUTS_BE_CPP::single_line_comment ("attribute setter: " + name)
    << "virtual void " << name << " (";

  CUTS_BE_CCM::Cpp::In_Type_Generator in_type_header_gen (this->ctx_.header_);
  in_type_header_gen.generate (member_type);

  this->ctx_.header_
    << " " << name << ");"
    << std::endl;

  // This part generates the source information.
  this->ctx_.source_
    << CUTS_BE_CPP::function_header ("attribute setter: " + name)
    << "void " << parent_name << "::" << name << " (";

  CUTS_BE_CCM::Cpp::In_Type_Generator in_type_source_gen (this->ctx_.source_);
  in_type_source_gen.generate (member_type);

  this->ctx_.source_
    << " " << name << ")"
    << "{";
}

///////////////////////////////////////////////////////////////////////////////
// CUTS_BE_Attribute_End_T

void CUTS_BE_Attribute_End_T <CUTS_BE_CCM::Cpp::Context>::
generate (const CHAOS::Attribute & attr)
{
  CHAOS::AttributeMember member = attr.AttributeMember_child ();
  if (Udm::null == member)
    return;

  CHAOS::MemberType type = member.ref ();
  if (Udm::null == type)
    return;

  Uml::Class meta = type.type ();
  std::string attr_name (attr.name ());

  this->ctx_.source_
    << "this->" << attr_name << "_ = ";

  if (meta == CHAOS::GenericObject::meta)
  {
    // We need to create a duplicate copy of the interface
    // before we store it.
    this->ctx_.source_
      << std::endl
      << "  ::CORBA::Object::_duplicate (" << attr_name << ");";
  }
  else if (meta == CHAOS::TypeEncoding::meta)
  {
    // We need to create a duplicate copy of the typecode
    // interface before we store it.
    this->ctx_.source_
      << std::endl
      << "  ::CORBA::TypeCode::_duplicate (" << attr_name << ");";
  }
  else
  {
    this->ctx_.source_ << attr_name << ";";
  }

  this->ctx_.source_
    << "}";

  // Make sure we generate the <readonly> variant.
  this->readonly_begin_.generate (attr);
  this->readonly_end_.generate (attr);
}

///////////////////////////////////////////////////////////////////////////////
// CUTS_BE_ReadonlyAttribute_Begin_T

void CUTS_BE_ReadonlyAttribute_Begin_T <CUTS_BE_CCM::Cpp::Context>::
generate (const CHAOS::ReadonlyAttribute & attr)
{
  CHAOS::AttributeMember member = attr.AttributeMember_child ();
  if (member == Udm::null)
    return;

  CHAOS::MemberType type = member.ref ();
  if (type == Udm::null)
    return;

  std::string attr_name (attr.name ());
  CHAOS::Component parent = CHAOS::Component::Cast (attr.parent ());

  // This part of the code generate to the header file.
  this->ctx_.header_
    << CUTS_BE_CPP::single_line_comment ("attribute getter: " + attr_name)
    << "virtual ";

  CUTS_BE_CCM::Cpp::Retn_Type_Generator retn_header_gen (this->ctx_.header_);
  retn_header_gen.generate (type);

  this->ctx_.header_
    << " " << attr_name << " (void);"
    << std::endl;

  // This part of the code generate to the source file.
  this->ctx_.source_
    << CUTS_BE_CPP::function_header ("attribute getter: " + attr_name);

  CUTS_BE_CCM::Cpp::Retn_Type_Generator retn_source_gen (this->ctx_.source_);
  retn_source_gen.generate (type);

  this->ctx_.source_
    << " " << parent.name () << "::" << attr_name << " (void)"
    << "{";
}

///////////////////////////////////////////////////////////////////////////////
// CUTS_BE_ReadonlyAttribute_End_T

void CUTS_BE_ReadonlyAttribute_End_T <CUTS_BE_CCM::Cpp::Context>::
generate (const CHAOS::ReadonlyAttribute & attr)
{
  CHAOS::AttributeMember member = attr.AttributeMember_child ();

  if (member == Udm::null)
    return;

  CHAOS::MemberType type = member.ref ();

  if (type == Udm::null)
    return;

  Uml::Class meta = type.type ();
  std::string attr_name (attr.name ());

  // This section of the code write the source file.

  if (meta == CHAOS::String::meta)
  {
    // Strings are special case. We need to return a duplicate
    // copy of the string, or we will have major problems.
    this->ctx_.source_
      << "::CORBA::String_var s =" << std::endl
      << "  ::CORBA::string_dup (this->"
      << attr_name << "_.c_str ());"
      << "return s._retn ();";
  }
  else if (meta == CHAOS::GenericValue::meta)
  {
    // We need to create an <Any::_var_type> for temporary
    // storage and give control to the client using the
    // _retn () method.
    this->ctx_.source_
      << "CORBA::Any * temp = 0;"
      << "ACE_NEW_THROW_EX (temp," << std::endl
      << "::CORBA::Any (this->" << attr_name << "_)," << std::endl
      << "::CORBA::NO_MEMORY ());"
      << "return temp;";
  }
  else if (meta == CHAOS::GenericObject::meta)
  {
    this->ctx_.source_
      << "return ::CORBA::Object::_duplicate (this->"
      << attr_name << "_.in ());";
  }
  else if (meta == CHAOS::TypeEncoding::meta)
  {
    this->ctx_.source_
      << "return ::CORBA::TypeCode::_duplicate (this->"
      << attr_name << "_.in ());";
  }
  else
  {
    this->ctx_.source_
      << "return this->" << attr.name () << "_;";
  }

  this->ctx_.source_
    << "}";
}


///////////////////////////////////////////////////////////////////////////////
// CUTS_BE_PeriodicEvent_Begin_T

void CUTS_BE_PeriodicEvent_Begin_T <CUTS_BE_CCM::Cpp::Context>::
generate (const CHAOS::PeriodicEvent & periodic)
{
  std::string name = periodic.name ();
  std::string func_name = "periodic_" + name;

  CHAOS::Component parent (CHAOS::Component::Cast (periodic.parent ()));
  std::string parent_name (parent.name ());

  this->ctx_.header_
    << CUTS_BE_CPP::single_line_comment ("PeriodicEvent: " + name)
    << "void " << func_name << " (void);"
    << std::endl;

  this->ctx_.source_
    << CUTS_BE_CPP::function_header ("PeriodicEvent: " + name)
    << "void " << parent_name << "::" << func_name << " (void)"
    << "{";
}

///////////////////////////////////////////////////////////////////////////////
// CUTS_BE_PeriodicEvent_End_T

void CUTS_BE_PeriodicEvent_End_T <CUTS_BE_CCM::Cpp::Context>::
generate (const CHAOS::PeriodicEvent & periodic)
{
  this->ctx_.source_
    << "}";
}

///////////////////////////////////////////////////////////////////////////////
// CUTS_BE_InEventPort_Begin_T

void CUTS_BE_InEventPort_Begin_T <CUTS_BE_CCM::Cpp::Context>::
generate (const CHAOS::InEventPort & sink,
          const std::vector <CHAOS::Property> & properties)
{
  CHAOS::Event event = sink.ref ();

  if (event == Udm::null)
    return;

  CHAOS::Component parent = CHAOS::Component::Cast (sink.parent ());
  std::string parent_name (parent.name ());
  std::string name (sink.name ());
  std::string fq_name (CUTS_BE_CPP::fq_type (event));

  this->ctx_.header_
    << CUTS_BE_CPP::single_line_comment ("sink: " + name)
    << "virtual void push_" << name << " (" << fq_name << " * ev);"
    << std::endl;

  this->ctx_.source_
    << CUTS_BE_CPP::function_header ("sink: " + name)
    << "void " << parent_name << "::push_" << name << " (" << fq_name << " * ev)"
    << "{";
}

///////////////////////////////////////////////////////////////////////////////
// CUTS_BE_InEventPort_End_T

void CUTS_BE_InEventPort_End_T <CUTS_BE_CCM::Cpp::Context>::
generate (const CHAOS::InEventPort & attr,
          const std::vector <CHAOS::Property> & properties)
{
  this->ctx_.source_
    << "ACE_UNUSED_ARG (ev);"
    << "}";
}

///////////////////////////////////////////////////////////////////////////////
// CUTS_BE_ProvidedRequestPort_Begin_T

void CUTS_BE_ProvidedRequestPort_Begin_T <CUTS_BE_CCM::Cpp::Context>::
generate (const CHAOS::ProvidedRequestPort & facet)
{
  CHAOS::Object obj = CHAOS::Object::Cast (facet.ref ());

  if (Udm::null == obj)
    return;

  CHAOS::Component parent (CHAOS::Component::Cast (facet.parent ()));
  std::string parent_name (parent.name ());
  std::string scope (CUTS_BE_CPP::scope (obj));
  std::string name (facet.name ());
  std::string func ("get_" + name);

  this->ctx_.header_
    << CUTS_BE_CPP::single_line_comment ("facet: " + name)
    << "virtual " << scope << "CCM_" << name << "_ptr" << std::endl
    << "  " << func << " (void);"
    << std::endl;

  this->ctx_.source_
    << CUTS_BE_CPP::function_header ("facet: " + name)
    << scope << "CCM_" << name << "_ptr" << std::endl
    << "  " << parent_name << "::" << func << " (void)"
    << "{";
}

///////////////////////////////////////////////////////////////////////////////
// CUTS_BE_ProvidedRequestPort_End_T

void CUTS_BE_ProvidedRequestPort_End_T <CUTS_BE_CCM::Cpp::Context>::
generate (const CHAOS::ProvidedRequestPort & port)
{
  CHAOS::Object obj = CHAOS::Object::Cast (port.ref ());

  if (obj == Udm::null)
    return;

  std::string obj_scope (CUTS_BE_CPP::scope (obj));
  std::string name (obj.name ());

  this->ctx_.source_
    << "return " << obj_scope << "CCM_" << name << "::_nil ();"
    << "}";
}

namespace CUTS_BE_CCM
{
//
// Type_System
//
Type_System::Type_System (std::ostream & out)
: out_ (out),
  predefined_types_ (this)
{
  this->predefined_types_.insert <CHAOS::Boolean> ();
  this->predefined_types_.insert <CHAOS::Byte> ();
  this->predefined_types_.insert <CHAOS::GenericObject> ();
  this->predefined_types_.insert <CHAOS::GenericValue> ();
  this->predefined_types_.insert <CHAOS::LongInteger> ();
  this->predefined_types_.insert <CHAOS::RealNumber> ();
  this->predefined_types_.insert <CHAOS::ShortInteger> ();
  this->predefined_types_.insert <CHAOS::String> ();
  this->predefined_types_.insert <CHAOS::TypeEncoding> ();
  this->predefined_types_.insert <CHAOS::TypeKind> ();
}

//
// generate
//
void Type_System::generate (const CHAOS::MemberType & mt)
{
  if (Udm::IsDerivedFrom (mt.type (), CHAOS::PredefinedType::meta))
  {
    CHAOS::PredefinedType ptype = CHAOS::PredefinedType::Cast (mt);
    this->predefined_types_.dispatch (ptype);
  }
  else
  {
    CHAOS::NamedType named = CHAOS::NamedType::Cast (mt);
    this->out_ << CUTS_BE_CPP::fq_type (named);
  }
}

namespace Cpp
{
///////////////////////////////////////////////////////////////////////////////
// In_Type_Generator

//
// In_Type_Generator
//
In_Type_Generator::In_Type_Generator (std::ostream & out)
: Type_System (out)

{
}

//
// ~In_Type_Generator
//
In_Type_Generator::~In_Type_Generator (void)
{

}

//
// Visit_Boolean
//
void In_Type_Generator::
Visit_Boolean (const CHAOS::Boolean & value)
{
  this->out_ << "::CORBA::Boolean";
}

//
// Visit_Byte
//
void In_Type_Generator::
Visit_Byte (const CHAOS::Byte & byte)
{
  this->out_ << "::CORBA::Octet";
}

//
// Visit_LongInteger
//
void In_Type_Generator::
Visit_LongInteger (const CHAOS::LongInteger & value)
{
  this->out_ << "::CORBA::Long";
}

//
// Visit_ShortInteger
//
void In_Type_Generator::
Visit_ShortInteger (const CHAOS::ShortInteger & value)
{
  this->out_ << "::CORBA::Short";
}

//
// Visit_String
//
void In_Type_Generator::
Visit_String (const CHAOS::String & value)
{
  this->out_ << "const char *";
}

//
// Visit_RealNumber
//
void In_Type_Generator::
Visit_RealNumber (const CHAOS::RealNumber & value)
{
  this->out_ << "::CORBA::Double";
}

//
// Visit_GenericValue
//
void In_Type_Generator::
Visit_GenericValue (const CHAOS::GenericValue & value)
{
  this->out_ << "const ::CORBA::Any &";
}

//
// Visit_GenericObject
//
void In_Type_Generator::
Visit_GenericObject (const CHAOS::GenericObject & value)
{
  this->out_ << "::CORBA::Object_ptr";
}

//
// Visit_TypeKind
//
void In_Type_Generator::
Visit_TypeKind (const CHAOS::TypeKind & value)
{
  this->out_ << "::CORBA::TCKind";
}

//
// Visit_TypeEncoding
//
void In_Type_Generator::
Visit_TypeEncoding (const CHAOS::TypeEncoding & value)
{
  this->out_ << "::CORBA::TypeCode_ptr";
}

///////////////////////////////////////////////////////////////////////////////
// Out_Type_Generator

//
// Out_Type_Generator
//
Out_Type_Generator::Out_Type_Generator (std::ostream & out)
: Type_System (out)
{

}

//
// ~Out_Type_Generator
//
Out_Type_Generator::~Out_Type_Generator (void)
{

}

//
// Visit_Boolean
//
void Out_Type_Generator::
Visit_Boolean (const CHAOS::Boolean & value)
{
  this->out_ << "::CORBA::Boolean_out";
}

//
// Visit_Byte
//
void Out_Type_Generator::
Visit_Byte (const CHAOS::Byte & byte)
{
  this->out_ << "::CORBA::Octet_out";
}

//
// Visit_LongInteger
//
void Out_Type_Generator::
Visit_LongInteger (const CHAOS::LongInteger & value)
{
  this->out_ << "::CORBA::Long_out";
}

//
// Visit_ShortInteger
//
void Out_Type_Generator::
Visit_ShortInteger (const CHAOS::ShortInteger & value)
{
  this->out_ << "::CORBA::Short_out";
}

//
// Visit_String
//
void Out_Type_Generator::
Visit_String (const CHAOS::String & value)
{
  this->out_ << "::CORBA::String_out";
}

//
// Visit_RealNumber
//
void Out_Type_Generator::
Visit_RealNumber (const CHAOS::RealNumber & value)
{
  this->out_ << "::CORBA::Double_out";
}

//
// Visit_GenericValue
//
void Out_Type_Generator::
Visit_GenericValue (const CHAOS::GenericValue & value)
{
  this->out_ << "::CORBA::Any_out";
}

//
// Visit_GenericObject
//
void Out_Type_Generator::
Visit_GenericObject (const CHAOS::GenericObject & value)
{
  this->out_ << "::CORBA::Object_out";
}

//
// Visit_TypeKind
//
void Out_Type_Generator::
Visit_TypeKind (const CHAOS::TypeKind & value)
{
  this->out_ << "::CORBA::TCKind_out";
}

//
// Visit_TypeEncoding
//
void Out_Type_Generator::
Visit_TypeEncoding (const CHAOS::TypeEncoding & value)
{
  this->out_ << "::CORBA::TypeCode_out";
}

///////////////////////////////////////////////////////////////////////////////
// In_Out_Type_Generator

//
// In_Out_Type_Generator
//
In_Out_Type_Generator::In_Out_Type_Generator (std::ostream & out)
: Type_System (out)
{

}

//
// ~In_Out_Type_Generator
//
In_Out_Type_Generator::~In_Out_Type_Generator (void)
{

}

//
// Visit_Boolean
//
void In_Out_Type_Generator::
Visit_Boolean (const CHAOS::Boolean & value)
{
  this->out_ << "::CORBA::Boolean &";
}

//
// Visit_Byte
//
void In_Out_Type_Generator::
Visit_Byte (const CHAOS::Byte & byte)
{
  this->out_ << "::CORBA::Octet &";
}

//
// Visit_LongInteger
//
void In_Out_Type_Generator::
Visit_LongInteger (const CHAOS::LongInteger & value)
{
  this->out_ << "::CORBA::Long &";
}

//
// Visit_ShortInteger
//
void In_Out_Type_Generator::
Visit_ShortInteger (const CHAOS::ShortInteger & value)
{
  this->out_ << "::CORBA::Short &";
}

//
// Visit_String
//
void In_Out_Type_Generator::
Visit_String (const CHAOS::String & value)
{
  this->out_ << "::CORBA::String * &";
}

//
// Visit_RealNumber
//
void In_Out_Type_Generator::
Visit_RealNumber (const CHAOS::RealNumber & value)
{
  this->out_ << "::CORBA::Double &";
}

//
// Visit_GenericValue
//
void In_Out_Type_Generator::
Visit_GenericValue (const CHAOS::GenericValue & value)
{
  this->out_ << "::CORBA::Any &";
}

//
// Visit_GenericObject
//
void In_Out_Type_Generator::
Visit_GenericObject (const CHAOS::GenericObject & value)
{
  this->out_ << "::CORBA::Object_ptr &";
}

//
// Visit_TypeKind
//
void In_Out_Type_Generator::
Visit_TypeKind (const CHAOS::TypeKind & value)
{
  this->out_ << "::CORBA::TCKind &";
}

//
// Visit_TypeEncoding
//
void In_Out_Type_Generator::
Visit_TypeEncoding (const CHAOS::TypeEncoding & value)
{
  this->out_ << "::CORBA::TypeCode_ptr &";
}

///////////////////////////////////////////////////////////////////////////////
// Retn_Type_Generator

//
// Retn_Type_Generator
//
Retn_Type_Generator::Retn_Type_Generator (std::ostream & out)
: Type_System (out)
{

}

//
// ~Retn_Type_Generator
//
Retn_Type_Generator::~Retn_Type_Generator (void)
{

}

//
// generate
//
void Retn_Type_Generator::
generate (const CHAOS::MemberType & type)
{
  Type_System::generate (type);

  if (this->is_variable_type (type))
    this->out_ << " *";
}

//
// Visit_Boolean
//
void Retn_Type_Generator::
Visit_Boolean (const CHAOS::Boolean & value)
{
  this->out_ << "::CORBA::Boolean";
}

//
// Visit_Byte
//
void Retn_Type_Generator::
Visit_Byte (const CHAOS::Byte & byte)
{
  this->out_ << "::CORBA::Octet";
}

//
// Visit_LongInteger
//
void Retn_Type_Generator::
Visit_LongInteger (const CHAOS::LongInteger & value)
{
  this->out_ << "::CORBA::Long";
}

//
// Visit_ShortInteger
//
void Retn_Type_Generator::
Visit_ShortInteger (const CHAOS::ShortInteger & value)
{
  this->out_ << "::CORBA::Short";
}

//
// Visit_String
//
void Retn_Type_Generator::
Visit_String (const CHAOS::String & value)
{
  this->out_ << "char";
}

//
// Visit_RealNumber
//
void Retn_Type_Generator::
Visit_RealNumber (const CHAOS::RealNumber & value)
{
  this->out_ << "::CORBA::Double";
}

//
// Visit_GenericValue
//
void Retn_Type_Generator::
Visit_GenericValue (const CHAOS::GenericValue & value)
{
  this->out_ << "::CORBA::Any";
}

//
// Visit_GenericObject
//
void Retn_Type_Generator::
Visit_GenericObject (const CHAOS::GenericObject & value)
{
  this->out_ << "::CORBA::Object_ptr";
}

//
// Visit_TypeKind
//
void Retn_Type_Generator::
Visit_TypeKind (const CHAOS::TypeKind & value)
{
  this->out_ << "::CORBA::TCKind";
}

//
// Visit_TypeEncoding
//
void Retn_Type_Generator::
Visit_TypeEncoding (const CHAOS::TypeEncoding & value)
{
  this->out_ << "::CORBA::TypeCode_ptr";
}

//
// is_variable_type
//
bool Retn_Type_Generator::
is_variable_type (const CHAOS::MemberType & type)
{
  bool result;
  Uml::Class meta_type = type.type ();

  if (Udm::IsDerivedFrom (meta_type, CHAOS::PredefinedType::meta))
  {
    result = (meta_type == CHAOS::String::meta || meta_type == CHAOS::GenericValue::meta);
  }
  else if (meta_type == CHAOS::Aggregate::meta)
  {
    // Extract the aggregate from the member type.
    const CHAOS::Aggregate aggr = CHAOS::Aggregate::Cast (type);

    // Get the members of the aggregate.
    typedef std::vector <CHAOS::Member> Member_Set;
    Member_Set members = aggr.Member_children ();

    Member_Set::const_iterator
      iter = members.begin (),
      iter_end = members.end ();

    // Initialize the result.
    result = false;

    for (; iter != iter_end; iter ++)
    {
      // Get the next member in the data structure.
      CHAOS::MemberType mtype = iter->ref ();

      // Determine if it is a variable type.
      if (mtype != Udm::null)
        result |= this->is_variable_type (mtype);

      // We can quit once we have found one.
      if (result)
        break;
    }
  }
  else if (meta_type == CHAOS::SwitchedAggregate::meta)
  {
    const CHAOS::SwitchedAggregate swaggr = CHAOS::SwitchedAggregate::Cast (type);

    // Get the members of the aggregate.
    typedef std::vector <CHAOS::Member> Member_Set;
    Member_Set members = swaggr.Member_children ();

    Member_Set::const_iterator
      iter = members.begin (),
      iter_end = members.end ();

    // Initialize the result.
    result = false;

    for (; iter != iter_end; iter ++)
    {
      // Get the next member in the data structure.
      CHAOS::MemberType mtype = iter->ref ();

      // Determine if it is a variable type.
      if (mtype != Udm::null)
        result |= this->is_variable_type (mtype);

      // We can quit once we have found one.
      if (result)
        break;
    }
  }
  else if (meta_type == CHAOS::Collection::meta)
  {
    result = true;
  }
  else if (meta_type == CHAOS::Alias::meta)
  {
    const CHAOS::Alias alias = CHAOS::Alias::Cast (type);
    CHAOS::MemberType mtype = alias.ref ();

    if (mtype != Udm::null)
      result = this->is_variable_type (mtype);
  }
  else
  {
    result = false;
  }

  return result;
}


///////////////////////////////////////////////////////////////////////////////
// Attribute_Method_Generator

//
// Attribute_Method_Generator
//
Attribute_Method_Generator::Attribute_Method_Generator (std::ostream & out)
: out_ (out)
{

}

//
// ~Attribute_Method_Generator
//
Attribute_Method_Generator::~Attribute_Method_Generator (void)
{

}

//
// Visit_Attribute
//
void Attribute_Method_Generator::
Visit_Attribute (const CHAOS::Attribute & attr)
{
  // Write the name of the attribute method.
  std::string name = attr.name ();
  this->out_ << name << " (";

  CHAOS::AttributeMember member = attr.AttributeMember_child ();

  if (Udm::null != member)
    member.Accept (*this);

  this->out_ << " " << name << ")";
}

//
// Visit_AttributeMember
//
void Attribute_Method_Generator::
Visit_AttributeMember (const CHAOS::AttributeMember & member)
{
  CHAOS::MemberType mtype = member.ref ();

  if (Udm::null != mtype)
  {
    In_Type_Generator intype (this->out_);
    intype.generate (mtype);
  }
}

//
// Visit_ReadonlyAttribute
//
void Attribute_Method_Generator::
Visit_ReadonlyAttribute (const CHAOS::ReadonlyAttribute & ro_attr)
{
  this->out_ << ro_attr.name () << " (void)";
}

//
// InEvent_Method_Generator
//
InEvent_Method_Generator::
InEvent_Method_Generator (std::ostream & out)
: out_ (out)
{

}

//
// ~InEvent_Method_Generator
//
InEvent_Method_Generator::~InEvent_Method_Generator (void)
{

}

//
// Visit_InEventPort
//
void InEvent_Method_Generator::
Visit_InEventPort (const CHAOS::InEventPort & port)
{
  this->out_ << "push_" << port.name () << " (";

}

}   // namespace Cpp
}   // namespace CUTS_BE_CCM
